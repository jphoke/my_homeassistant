"""
YAML snippet generator for the reTerminal Dashboard Designer integration.

This module takes the internal layout model (DeviceConfig / PageConfig / WidgetConfig)
and produces ESPHome-compatible YAML snippets that the user can paste BELOW an
existing base ESPHome config.

Key principles:
- We DO NOT emit:
  - esphome:
  - esp32:
  - wifi:
  - api:
  - ota:
  - logger:
- We ONLY emit additive blocks:
  - globals, fonts, outputs, rtttl, sensors, text_sensors, scripts, display, etc.
- We target the reTerminal E1001 epaper (800x480) as the initial device.

The output is a single YAML snippet string containing:
- Header comments explaining how to use it.
- Behavior/config blocks (buttons, scripts, etc).
- Layout block(s) mapping configured pages/widgets to display lambda code.

NOTE: This is an MVP generator:
- Focus on safe, deterministic output.
- Supports a conservative subset of widget types.
- Uses IDs and structures inspired by the working reference in:
  resources/ESPHome Reterminal/reterminalE-1001-esphome.txt
"""

from __future__ import annotations

import logging
from typing import List

from .models import DeviceConfig, PageConfig, WidgetConfig
from .const import IMAGE_WIDTH, IMAGE_HEIGHT

_LOGGER = logging.getLogger(__name__)


SNIPPET_HEADER = """# ============================================================
# Generated by reTerminal Dashboard Designer
# Target device: reTerminal E1001 (800x480 epaper)
#
# Usage:
# 1. Ensure you already have a working base ESPHome config for your device:
#    - Includes: esphome, esp32, wifi, api, ota, logger
#    - Uses the correct board for the reTerminal E1001
# 2. Paste this snippet BELOW your existing base config.
# 3. Do NOT duplicate esphome:, wifi:, api:, ota:, logger: sections.
# 4. If you already define conflicting ids (e.g. epaper_display), adjust accordingly.
#
# WARNING:
# - This is an MVP generator. Review the result before flashing.
# - Keep this snippet under version control to track your layout changes.
# ============================================================
"""


def generate_snippet(device: DeviceConfig) -> str:
    """
    Generate a complete YAML snippet for the given device configuration.

    The snippet includes:
    - Required globals/fonts/outputs/rtttl/buttons/sensors/scripts for navigation.
    - A display: epaper_display block with lambda that renders all pages/widgets.

    This function assumes:
    - Single device_type: reTerminal E1001.
    - IMAGE_WIDTH/IMAGE_HEIGHT match the target display (800x480).
    """
    device.ensure_pages()

    parts: List[str] = [SNIPPET_HEADER.rstrip(), ""]

    # Core pieces (ordered for readability)
    # NOTE: output, rtttl, sensor, time are provided by hardware template
    # We only generate: globals, fonts, text_sensor, button, script, display
    
    # Pre-classify entities to determine numeric vs text vs local
    text_entity_ids, numeric_entity_ids, local_entity_ids = _classify_entities(device)
    
    parts.append(_generate_globals())
    parts.append(_generate_fonts(device))  # Pass device to collect icon glyphs
    parts.append(_generate_text_sensors(device, text_entity_ids, numeric_entity_ids, local_entity_ids))  # Only text_sensors for HA entities
    parts.append(_generate_online_images(device))
    parts.append(_generate_deep_sleep(device))
    parts.append(_generate_navigation_buttons(device))
    parts.append(_generate_scripts(device))
    parts.append(_generate_graphs(device))
    parts.append(_generate_display_block(device, numeric_entity_ids))

    # Join with double newlines between major sections
    return "\n\n".join(p for p in parts if p.strip())


def _generate_globals() -> str:
    return """globals:
  # Current page index (0-based)
  - id: display_page
    type: int
    restore_value: true
    initial_value: '0'

  # Battery icon glyph (optional usage in display lambda)
  - id: battery_glyph
    type: std::string
    restore_value: no
    initial_value: '"\\U000F0079"'

  # Default page refresh interval (seconds)
  - id: page_refresh_default_s
    type: int
    restore_value: no
    initial_value: '900'

  # Current computed refresh interval (seconds)
  - id: page_refresh_current_s
    type: int
    restore_value: no
    initial_value: '900'
"""


def _generate_deep_sleep(device: DeviceConfig) -> str:
    """
    Generate deep_sleep configuration for power saving.
    """
    if not device.deep_sleep_enabled:
        return ""

    # run_duration: 30s gives enough time to connect, fetch time/sensors, and render.
    # sleep_duration: user configured interval.
    return f"""deep_sleep:
  id: deep_sleep_1
  run_duration: 30s
  sleep_duration: {device.deep_sleep_interval}s
"""


def _generate_fonts(device: DeviceConfig) -> str:
    """
    Generate font definitions including Material Design Icons fonts for icon widgets.
    Collects all icon codes from the device and generates appropriate MDI fonts.
    Also generates image definitions for image widgets.
    Supports font family selection - uses the first font_family found in widgets, defaults to Inter.
    """
    # Collect all unique icon codes from icon widgets
    icon_codes = set()
    # Collect all unique image paths from image widgets and icon sizes
    image_paths = {}
    icon_sizes = set()  # Track unique icon sizes
    text_sizes = set()  # Track unique text font sizes
    selected_font_family = "Inter"  # Default font family
    
    for page in device.pages:
        for widget in page.widgets:
            wtype = (widget.type or "").lower()
            if wtype == "icon":
                props = widget.props or {}
                code = (props.get("code") or "").strip()
                if code:
                    icon_codes.add(code)
                # Collect icon size if specified
                size = int(props.get("size", 48) or 48)
                icon_sizes.add(size)
            elif wtype == "battery_icon":
                # Battery icons need all battery level glyphs
                props = widget.props or {}
                # Add all battery icon codes
                for code in ["F0079", "F007A", "F007B", "F007C", "F007D", "F007E", "F007F", "F0080", "F0081", "F0082"]:
                    icon_codes.add(code)
                # Collect icon size if specified
                size = int(props.get("size", 48) or 48)
                icon_sizes.add(size)
            elif wtype == "weather_icon":
                # Weather icons need all weather state glyphs
                props = widget.props or {}
                # Add all weather icon codes
                for code in ["F0591", "F0594", "F0595", "F192C", "F0E6E", "F0598", "F067F", "F0599", "F06A1", "F0596", "F0590", "F0F32", "F0597", "F0F2F", "F0024"]:
                    icon_codes.add(code)
                # Collect icon size if specified
                size = int(props.get("size", 48) or 48)
                icon_sizes.add(size)
            elif wtype in ("text", "label", "sensor_text"):
                props = widget.props or {}
                # Get font family from first widget that has it
                family = props.get("font_family")
                if family and selected_font_family == "Inter":
                    selected_font_family = family
                
                # Get weight (default 400)
                weight = int(props.get("font_weight", 400) or 400)
                
                # Collect text font size if specified
                if wtype in ("text", "label"):
                    size = int(props.get("font_size", 0) or 0)
                    if size > 0:
                        text_sizes.add((size, weight))
                else:  # sensor_text
                    label_size = int(props.get("label_font_size", 0) or 0)
                    value_size = int(props.get("value_font_size", 0) or 0)
                    if label_size > 0:
                        text_sizes.add((label_size, weight))
                    if value_size > 0:
                        text_sizes.add((value_size, weight))
            elif wtype == "datetime":
                props = widget.props or {}
                # Datetime usually uses standard weights, but we can support custom if needed
                # For now, assume standard weights for datetime to avoid complexity unless requested
                time_size = int(props.get("time_font_size", 0) or 0)
                date_size = int(props.get("date_font_size", 0) or 0)
                if time_size > 0:
                    text_sizes.add((time_size, 700)) # Time usually bold
                if date_size > 0:
                    text_sizes.add((date_size, 400)) # Date usually regular
            elif wtype == "image":
                props = widget.props or {}
                path = (props.get("path") or "").strip()
                if path:
                    # Replicate clamping logic to match _append_widget_render
                    x = max(0, min(widget.x, IMAGE_WIDTH))
                    y = max(0, min(widget.y, IMAGE_HEIGHT))
                    width = max(1, min(widget.width, IMAGE_WIDTH - x))
                    height = max(1, min(widget.height, IMAGE_HEIGHT - y))

                    # Generate safe ID from path
                    safe_path = path.replace("/", "_").replace(".", "_").replace("-", "_").replace(" ", "_")
                    safe_id = f"img_{safe_path}_{width}x{height}"
                    
                    # Collect properties
                    img_type = props.get("image_type", "BINARY").upper()
                    dither = props.get("dither", "FLOYDSTEINBERG").upper()
                    transparency = props.get("transparency", "").lower()
                    
                    # Store path with dimensions and config
                    # Key by path+width+height to allow same image at different sizes
                    key = (path, width, height)
                    image_paths[key] = {
                        "id": safe_id,
                        "width": width,
                        "height": height,
                        "type": img_type,
                        "dither": dither,
                        "transparency": transparency
                    }
    
    # Base fonts - use selected font family for all standard sizes
    font_lines = [
        "font:",
        f"  - file: \"gfonts://{selected_font_family}@400\"",
        "    id: font_axis",
        "    size: 10",
        "",
        f"  - file: \"gfonts://{selected_font_family}@400\"",
        "    id: font_small",
        "    size: 19",
        "",
        f"  - file: \"gfonts://{selected_font_family}@500\"",
        "    id: font_normal",
        "    size: 22",
        "",
        f"  - file: \"gfonts://{selected_font_family}@700\"",
        "    id: font_header",
        "    size: 24"
    ]
    
    # Add custom text fonts for non-standard sizes or weights
    if text_sizes:
        font_lines.append("")
        font_lines.append("  # Custom text fonts for specific sizes and weights")
        for size, weight in sorted(text_sizes):
            # Check if this matches a standard font exactly
            if size == 19 and weight == 400: continue
            if size == 22 and weight == 500: continue
            if size == 24 and weight == 700: continue
            
            font_lines.extend([
                f"  - file: \"gfonts://{selected_font_family}@{weight}\"",
                f"    id: font_text_{size}_{weight}",
                f"    size: {size}"
            ])
    
    # Add MDI fonts if there are icon widgets
    if icon_codes:
        # Convert codes to Unicode escapes
        glyphs = []
        for code in sorted(icon_codes):
            # code is like "F0595" - convert to "\U000F0595"
            glyphs.append(f'"\\U000{code}"')
        
        glyph_list = ", ".join(glyphs)
        
        # Generate fonts for each unique size
        if not icon_sizes:
            icon_sizes = {48}  # Default size
        
        font_lines.extend([
            "",
            "  # Material Design Icons for icon widgets",
            "  # Copy materialdesignicons-webfont.ttf to your ESPHome fonts folder"
        ])
        
        # Generate a font for each unique size
        for size in sorted(icon_sizes):
            # Always use size-specific ID for consistency
            font_id = f"font_mdi_{size}"
            
            font_lines.extend([
                "  - file: fonts/materialdesignicons-webfont.ttf",
                f"    id: {font_id}",
                f"    size: {size}",
                f"    glyphs: [{glyph_list}]"
            ])
    
    result = "\n".join(font_lines)
    
    # Add image definitions if there are image widgets
    if image_paths:
        result += "\n\n\nimage:"
        for (path, width, height), img_data in sorted(image_paths.items()):
            img_id = img_data["id"]
            img_type = img_data.get("type", "BINARY")
            dither = img_data.get("dither", "FLOYDSTEINBERG")
            transparency = img_data.get("transparency", "")
            
            result += f"\n  - file: \"{path}\""
            result += f"\n    id: {img_id}"
            result += f"\n    resize: {width}x{height}"
            result += f"\n    type: {img_type}"
            
            # Dither only applies to BINARY and GRAYSCALE
            if img_type in ("BINARY", "GRAYSCALE"):
                result += f"\n    dither: {dither}"
            
            # Transparency
            if transparency:
                result += f"\n    transparency: {transparency}"
    
    return result


# Removed _generate_outputs_and_buzzer() - now in hardware template


def _generate_text_sensors(device: DeviceConfig, text_entity_ids: set[str], numeric_entity_ids: dict[str, int], local_entity_ids: set[str]) -> str:
    """
    Generate text_sensor and sensor blocks for HomeAssistant entities.
    - text_sensor: for sensor_text widgets (string values)
    - sensor: for progress_bar, battery_icon, graph, and sensor_text with precision (numeric values)
    
    NOTE: To avoid "Duplicate key" errors, we output these as commented instructions
    or a list of items that the user must paste into their existing config.
    
    Local entities are skipped entirely as they are defined in the base ESPHome config.
    """
            
    sections = []
    
    # Generate text_sensor section for text-based widgets
    if text_entity_ids:
        sections.append("text_sensor:")
        for entity_id in sorted(text_entity_ids):
            # Skip local sensors - they are defined in base config
            if entity_id in local_entity_ids:
                continue
            # Skip local IDs (no dot) - assume they are defined elsewhere
            if "." not in entity_id:
                continue
            safe_id = entity_id.replace(".", "_").replace("-", "_")
            sections.append(f"""  - platform: homeassistant
    id: {safe_id}
    entity_id: {entity_id}
    internal: true""")
        sections.append("")
    
    # Generate sensor section for numeric widgets
    # Generate sensor section for numeric widgets
    if numeric_entity_ids:
        sections.append("# ============================================================================")
        sections.append("# INSTRUCTION: Copy these sensors into your existing 'sensor:' section")
        sections.append("# ============================================================================")
        sections.append("# sensor:")
        for entity_id in sorted(numeric_entity_ids.keys()):
            # Skip local sensors - they are defined in base config
            if entity_id in local_entity_ids:
                continue
            # Skip local IDs (no dot)
            if "." not in entity_id:
                continue
            safe_id = entity_id.replace(".", "_").replace("-", "_")
            precision = numeric_entity_ids[entity_id]
            
            sections.append(f"""#   - platform: homeassistant
#     id: {safe_id}
#     entity_id: {entity_id}
#     internal: true""")
            if precision >= 0:
                sections.append(f"#     accuracy_decimals: {precision}")
        sections.append("")
    
    if not sections:
        return "# No widgets with entities configured"
    
    return "\n".join(sections) + "\n"


def _classify_entities(device: DeviceConfig) -> tuple[set[str], dict[str, int], set[str]]:
    """
    Scan all widgets to determine which entities are text-based and which are numeric.
    Returns:
        text_entity_ids: Set of entity IDs to be treated as text_sensor
        numeric_entity_ids: Dict of entity IDs to be treated as sensor (value is precision)
        local_entity_ids: Set of entity IDs that are local/on-device (should not be generated)
    """
    text_entity_ids = set()
    numeric_entity_ids = {}  # Map entity_id -> max precision found (-1 = default)
    local_entity_ids = set()  # Track local sensors
    
    for page in device.pages:
        for widget in page.widgets:
            entity_id = (widget.entity_id or "").strip()
            if not entity_id:
                continue
            
            wtype = (widget.type or "").lower()
            props = widget.props or {}
            
            # Check both 'is_local_sensor' and 'local' for compatibility
            is_local = props.get("is_local_sensor") or props.get("local")
            if is_local:
                local_entity_ids.add(entity_id)
            
            # Widgets that need numeric (float) values
            if wtype in ("progress_bar", "battery_icon", "graph"):
                if entity_id not in numeric_entity_ids:
                    numeric_entity_ids[entity_id] = -1
            # Weather icon needs text state
            elif wtype == "weather_icon":
                if entity_id not in numeric_entity_ids:
                    text_entity_ids.add(entity_id)
            # sensor_text can be numeric if precision is specified
            elif wtype == "sensor_text":
                precision = int(props.get("precision", -1))
                
                # Local sensors are ALWAYS numeric
                if is_local:
                    current = numeric_entity_ids.get(entity_id, -2)
                    numeric_entity_ids[entity_id] = max(current, precision)
                # Has precision specified - treat as numeric
                elif precision >= 0:
                    current = numeric_entity_ids.get(entity_id, -2)
                    numeric_entity_ids[entity_id] = max(current, precision)
                # Default to text for HA entities without precision
                else:
                    if entity_id not in numeric_entity_ids:
                        text_entity_ids.add(entity_id)
            # Other widgets
            else:
                if entity_id not in numeric_entity_ids:
                    text_entity_ids.add(entity_id)
    
    # Remove entities from text_set if they are in numeric_set (numeric takes precedence)
    for eid in list(text_entity_ids):
        if eid in numeric_entity_ids:
            text_entity_ids.remove(eid)
            
    return text_entity_ids, numeric_entity_ids, local_entity_ids


def _generate_navigation_buttons(device: DeviceConfig) -> str:
    # Template buttons for navigation and refresh.
    # These operate on display_page and let HA/ESPHome automations drive page changes.
    num_pages = len(device.pages)
    
    # Start with basic navigation buttons
    buttons = ["""button:
  - platform: template
    name: "reTerminal Next Page"
    id: reterminal_next_page
    on_press:
      - lambda: |-
          int pages = {pages};
          id(display_page) = (id(display_page) + 1) % pages;

  - platform: template
    name: "reTerminal Previous Page"
    id: reterminal_prev_page
    on_press:
      - lambda: |-
          int pages = {pages};
          id(display_page) = (id(display_page) - 1 + pages) % pages;

  - platform: template
    name: "reTerminal Refresh Display"
    id: reterminal_refresh_display
    on_press:
      - component.update: epaper_display
""".format(pages=num_pages)]
    
    # Add "Go to Page X" buttons for each page
    for idx in range(num_pages):
        page_name = device.pages[idx].name if hasattr(device.pages[idx], 'name') and device.pages[idx].name else f"Page {idx}"
        buttons.append(f"""
  - platform: template
    name: "reTerminal Go to {page_name}"
    id: reterminal_goto_page_{idx}
    on_press:
      - lambda: 'id(display_page) = {idx};'
      - component.update: epaper_display""")
    
    # Add buzzer control buttons (hardware feature - always included)
    buttons.append("""

  # Buzzer control buttons (hardware feature)
  - platform: template
    name: "reTerminal Beep"
    id: reterminal_beep
    on_press:
      - rtttl.play: "beep:d=32,o=5,b=200:16e6"

  - platform: template
    name: "reTerminal Beep Error"
    id: reterminal_beep_error
    on_press:
      - rtttl.play: "error:d=16,o=5,b=200:c6"

  - platform: template
    name: "reTerminal Play Star Wars"
    id: reterminal_star_wars
    on_press:
      - rtttl.play: "StarWars:d=4,o=5,b=45:32p,32f,32f,32f,8a#.,8f.6,32d#,32d,32c,8a#.6,4f.6,32d#,32d,32c,8a#.6,4f.6,32d#,32d,32d#,8c6,32p,32f,32f,32f,8a#.,8f.6,32d#,32d,32c,8a#.6,4f.6,32d#,32d,32c,8a#.6,4f.6,32d#,32d,32d#,8c6"
""")
    
    return "".join(buttons)


def _generate_scripts(device: DeviceConfig) -> str:
    """
    Generate time + manage_run_and_sleep script with per-page refresh support.
    Includes night-time power saving logic if enabled.

    Semantics:
    - A global default interval (page_refresh_default_s).
    - Inline switch(page) using PageConfig.refresh_s values when provided.
    - Enforce a minimum of 60 seconds for any effective interval.
    - Night mode: Deep sleep between start_hour and end_hour, waking only at top of hour.
    """
    if device.manual_refresh_only:
        return """script:
  - id: manage_run_and_sleep
    mode: restart
    then:
      - logger.log: "Manual refresh only mode. Auto-refresh loop disabled."
"""

    case_lines: List[str] = []
    for idx, page in enumerate(device.pages):
        refresh = getattr(page, "refresh_s", None)
        if refresh is None:
            continue
        try:
            val = int(refresh)
        except (TypeError, ValueError):
            continue
        if val >= 60:
            case_lines.append(f"                  case {idx}: interval = {val}; break;")

    if case_lines:
        cases_block = "\n".join(case_lines)
    else:
        cases_block = "                  default:\n                    break;"

    # Sleep logic
    sleep_logic = ""
    if getattr(device, "sleep_enabled", False):
        start_h = int(getattr(device, "sleep_start_hour", 0))
        end_h = int(getattr(device, "sleep_end_hour", 5))
        
        # Handle wrap-around time (e.g. 22:00 to 06:00)
        if start_h > end_h:
            condition = f"(now.hour >= {start_h} || now.hour < {end_h})"
        else:
            condition = f"(now.hour >= {start_h} && now.hour < {end_h})"
            
        sleep_logic = f"""
      # Night Mode Check ({start_h:02d}:00 - {end_h:02d}:00)
      - if:
          condition:
            lambda: |-
              auto now = id(ha_time).now();
              if (!now.is_valid()) {{
                return false;
              }}
              // Deep sleep only between {start_h:02d}:00 and {end_h:02d}:00
              // But skip if it's exactly the top of the hour (we just woke up to refresh)
              return {condition} && !(now.minute == 0);
          then:
            - lambda: |-
                auto now = id(ha_time).now();
                if (now.is_valid()) {{
                  ESP_LOGI("sleep", "Deep sleep mode %02d:%02d", now.hour, now.minute);
                }}
            - if:
                condition:
                  lambda: |-
                    auto now = id(ha_time).now();
                    return now.is_valid() && (now.minute == 0);
                then:
                  - component.update: epaper_display
                else:
                  - logger.log: "Deep sleep mode: skipping refresh until the top of the hour."
            - deep_sleep.enter:
                id: deep_sleep_1
                sleep_duration: 60min
          
          # Active Mode
          else:"""
    else:
        # No sleep logic, just fall through to active mode
        sleep_logic = """
      # Sleep mode disabled
      - if:
          condition:
            lambda: 'return false;'
          then:
            - delay: 1s
          else:"""

    # No Refresh Logic
    no_refresh_logic = ""
    nr_start = getattr(device, "no_refresh_start_hour", None)
    nr_end = getattr(device, "no_refresh_end_hour", None)
    
    if nr_start is not None and nr_end is not None:
        try:
            s_h = int(nr_start)
            e_h = int(nr_end)
            if s_h > e_h:
                cond = f"(now.hour >= {s_h} || now.hour < {e_h})"
            else:
                cond = f"(now.hour >= {s_h} && now.hour < {e_h})"
            
            no_refresh_logic = f"""
            - if:
                condition:
                  lambda: |-
                    auto now = id(ha_time).now();
                    return now.is_valid() && {cond};
                then:
                  - logger.log: "In no-refresh window. Skipping display update."
                  - delay: 60s
                  - script.execute: manage_run_and_sleep
                  - script.stop: manage_run_and_sleep
            """
        except (ValueError, TypeError):
            pass

    return f"""script:
  - id: manage_run_and_sleep
    mode: restart
    then:
      - wait_until:
          condition:
            lambda: 'return id(ha_time).now().is_valid();'
          timeout: 120s
      {sleep_logic}
            - lambda: |-
                int page = id(display_page);
                int interval = id(page_refresh_default_s);
                switch (page) {{
{cases_block}
                }}
                if (interval < 60) {{
                  interval = 60;
                }}
                id(page_refresh_current_s) = interval;
                ESP_LOGI("refresh", "Next refresh in %d seconds for page %d", interval, page);
            
            {no_refresh_logic}
            - component.update: epaper_display
            - delay: !lambda 'return id(page_refresh_current_s) * 1000;'
            - script.execute: manage_run_and_sleep
"""


def _generate_graphs(device: DeviceConfig) -> str:
    """
    Generate graph definitions for graph widgets.
    """
    graph_widgets = []
    for page in device.pages:
        for widget in page.widgets:
            if (widget.type or "").lower() == "graph":
                graph_widgets.append(widget)
    
    if not graph_widgets:
        return "# No graph widgets configured"
        
    lines = ["graph:"]
    for widget in graph_widgets:
        props = widget.props or {}
        entity_id = (widget.entity_id or "").strip()
        if not entity_id:
            continue
            
        # Generate safe ID
        safe_id = f"graph_{widget.id}".replace("-", "_")
        
        lines.append(f"  - id: {safe_id}")
        lines.append(f"    duration: {props.get('duration', '1h')}")
        # Calculate clamped dimensions to ensure graph stays within bounds
        # This matches the logic in _append_widget_render
        x = max(0, min(widget.x, IMAGE_WIDTH))
        y = max(0, min(widget.y, IMAGE_HEIGHT))
        w = max(1, min(widget.width, IMAGE_WIDTH - x))
        h = max(1, min(widget.height, IMAGE_HEIGHT - y))

        lines.append(f"    width: {w}")
        lines.append(f"    height: {h}")
        
        # Optional border (default true in ESPHome, but we allow control)
        if "border" in props:
            lines.append(f"    border: {str(props['border']).lower()}")

        # Optional grid settings
        if props.get("x_grid"):
            lines.append(f"    x_grid: {props['x_grid']}")
        if props.get("y_grid"):
            lines.append(f"    y_grid: {props['y_grid']}")

        # Y-axis range settings
        if props.get("max_range"):
            lines.append(f"    max_range: {props['max_range']}")
        if props.get("min_range"):
            lines.append(f"    min_range: {props['min_range']}")
        if props.get("max_value"):
            lines.append(f"    max_value: {props['max_value']}")
        if props.get("min_value"):
            lines.append(f"    min_value: {props['min_value']}")
            
        # Traces (currently only one supported by editor UI)
        lines.append("    traces:")
        # Sanitize sensor ID for the trace
        safe_sensor_id = entity_id.replace(".", "_").replace("-", "_")
        lines.append(f"      - sensor: {safe_sensor_id}")
        
        # Trace styling
        if props.get("line_type"):
            lines.append(f"        line_type: {props['line_type']}")
        if props.get("line_thickness"):
            lines.append(f"        line_thickness: {props['line_thickness']}")
        if props.get("color"):
            # Map color name to ID if possible, or use raw value if it's a defined color id
            # For now, assuming standard colors or user-defined IDs
            color_val = props['color']
            if color_val in ["black", "white"]:
                 # ESPHome graph colors usually refer to a color ID defined in color: section
                 # We might need to define these if they don't exist, or use a default.
                 # For e-paper, it's usually just black/white.
                 pass 
            else:
                 lines.append(f"        color: {color_val}")
        if props.get("continuous"):
            lines.append(f"        continuous: true")

    return "\n".join(lines)


def _generate_display_block(device: DeviceConfig, numeric_entity_ids: dict[str, int]) -> str:
    """
    Generate the display: epaper_display block with a lambda that:
    - Reads current display_page.
    - Draws widgets belonging to the active page.
    - Uses DeviceConfig.orientation to pick rotation:
        - landscape -> rotation: 0
        - portrait  -> rotation: 90
    - DeviceConfig.dark_mode is advisory; widget-level color/invert decide actual draws.
    """
    lines: List[str] = []

    orientation = getattr(device, "orientation", "landscape")
    if orientation == "portrait":
        rotation = 90
    else:
        rotation = 0

    lines.append("display:")
    lines.append("  - platform: waveshare_epaper")
    lines.append("    id: epaper_display")
    lines.append(f"    model: {getattr(device, 'model', '7.50inv2')}")
    lines.append("    cs_pin: GPIO10")
    lines.append("    dc_pin: GPIO11")
    lines.append("    reset_pin:")
    lines.append("      number: GPIO12")
    lines.append("      inverted: false")
    lines.append("    busy_pin:")
    lines.append("      number: GPIO13")
    lines.append("      inverted: true")
    lines.append("    update_interval: never")
    lines.append("    lambda: |-")
    lines.append("      // Define common colors for widgets")
    lines.append("      Color COLOR_ON = Color(1);")
    lines.append("      Color COLOR_OFF = Color(0);")
    lines.append("      it.fill(COLOR_OFF);")
    lines.append("")

    for page_index, page in enumerate(device.pages):
        _append_page_render(lines, page_index, page, numeric_entity_ids)

    return "\n".join(lines)


def _generate_online_images(device: DeviceConfig) -> str:
    """
    Generate `online_image:` blocks for widgets of type `online_image`.
    Each widget becomes an `online_image` entry with an id derived from the widget id.
    """
    image_widgets = []
    for pidx, page in enumerate(device.pages):
        for widget in page.widgets:
            wtype = (widget.type or "").lower()
            if wtype == "online_image" or wtype == "puppet":
                image_widgets.append((pidx, widget))

    if not image_widgets:
        return "# No online_image widgets configured"

    lines: List[str] = [
        "# Remote/puppet images (online_image)",
        "# Required dependency for online_image",
        "http_request:",
        "  timeout: 20s",
        "  verify_ssl: false",
        ""
    ]
    for pidx, widget in image_widgets:
        props = widget.props or {}
        url = (props.get("url") or props.get("image_url") or "").strip()
        interval = int(props.get("interval_s") or 300)
        # Safe id for ESPHome
        safe_id = f"img_{widget.id}".replace("-", "_")
        lines.append(f"online_image:\n  - id: {safe_id}")
        if url:
            lines.append(f"    url: \"{url}\"")
        lines.append(f"    format: PNG")
        lines.append(f"    type: BINARY")
        lines.append(f"    update_interval: {interval}s")
        # on_download_finished: update epaper_display when this page is visible
        lines.append("    on_download_finished:")
        lines.append("      then:")
        lines.append(f"        - logger.log: \"Puppet image downloaded for widget {widget.id}\"")
        lines.append("        - if:")
        lines.append(f"            condition:")
        lines.append(f"              lambda: 'return id(display_page) == {pidx};'")
        lines.append(f"            then:")
        lines.append(f"              - component.update: epaper_display")
        lines.append("    on_error:")
        lines.append("      then:")
        lines.append(f"        - logger.log: \"Puppet image download FAILED for widget {widget.id}\"")

    return "\n".join(lines)


def _append_page_render(dst: List[str], page_index: int, page: PageConfig, numeric_entity_ids: dict[str, int]) -> None:
    indent = "      "
    dst.append(f'{indent}if (id(display_page) == {page_index}) {{')
    if not page.widgets:
        dst.append(f"{indent}  // Page {page_index}: no widgets configured.")
    else:
        for widget in page.widgets:
            _append_widget_render(dst, indent + "  ", widget, numeric_entity_ids)
    dst.append(f"{indent}}}")


def _resolve_font(props: dict, default_weight: int = 400) -> str:
    """Pick a font id based on optional font_size and font_weight in widget props."""
    try:
        size = int(props.get("font_size", 0))
    except (TypeError, ValueError):
        size = 0
        
    try:
        weight = int(props.get("font_weight", default_weight))
    except (TypeError, ValueError):
        weight = default_weight

    if size <= 0:
        return "id(font_normal)"
    
    # Check for standard fonts first
    if size == 19 and weight == 400:
        return "id(font_small)"
    if size == 22 and weight == 500:
        return "id(font_normal)"
    if size == 24 and weight == 700:
        return "id(font_header)"
        
    # Otherwise use generated custom font
    return f"id(font_text_{size}_{weight})"


def _resolve_font_by_size(size: int, weight: int = 400) -> str:
    """Pick a font id based on explicit font size and weight."""
    if size <= 0:
        return "id(font_normal)"
    
    # Check for standard fonts first
    if size == 19 and weight == 400:
        return "id(font_small)"
    if size == 22 and weight == 500:
        return "id(font_normal)"
    if size == 24 and weight == 700:
        return "id(font_header)"
        
    # Otherwise use generated custom font
    return f"id(font_text_{size}_{weight})"


def _wrap_with_condition(dst: List[str], indent: str, widget: WidgetConfig, content_lines: List[str], numeric_entity_ids: dict[str, int]) -> None:
    """Wrap widget rendering code with conditional visibility if configured."""
    # Check for Single Value mode
    has_single = (
        widget.condition_entity and 
        widget.condition_state is not None and 
        widget.condition_operator
    )
    
    # Check for Range mode
    has_range = (
        widget.condition_entity and 
        (widget.condition_min is not None or widget.condition_max is not None)
    )
    
    if not has_single and not has_range:
        # No condition - just append content
        dst.extend(content_lines)
        return
    
    # Generate safe ID from entity_id for condition
    if "." in widget.condition_entity:
        safe_cond_id = widget.condition_entity.replace(".", "_").replace("-", "_")
    else:
        safe_cond_id = widget.condition_entity
    
    # Determine if condition entity is numeric
    is_numeric = widget.condition_entity in numeric_entity_ids
    
    dst.append(f'{indent}{{')
    
    # Prepare value access
    if is_numeric:
        val_expr = f"id({safe_cond_id}).state"
    else:
        # For text sensors, we need to parse float for range or numeric ops
        dst.append(f'{indent}  float cond_val = atof(id({safe_cond_id}).state.c_str());')
        val_expr = "cond_val"

    if has_range:
        # Range Logic (Min/Max)
        # Default to AND (Inside) if not specified
        logic = (widget.condition_logic or "and").lower()
        
        parts = []
        if widget.condition_min is not None:
            parts.append(f"{val_expr} > {widget.condition_min}")
        if widget.condition_max is not None:
            parts.append(f"{val_expr} < {widget.condition_max}")
            
        if parts:
            join_op = " && " if logic == "and" else " || "
            condition = join_op.join(parts)
            dst.append(f'{indent}  if ({condition}) {{')
        else:
            # Should not happen if has_range is true, but fallback
            dst.append(f'{indent}  if (true) {{')
            
    else:
        # Single Value Logic
        cond_state = str(widget.condition_state).replace('"', '\\"')
        cond_op = widget.condition_operator or "=="
        
        if cond_op in (">", "<", ">=", "<="):
            # Numeric comparison
            if is_numeric:
                dst.append(f'{indent}  if ({val_expr} {cond_op} {cond_state}) {{')
            else:
                # Text sensor uses parsed float
                dst.append(f'{indent}  if ({val_expr} {cond_op} {cond_state}) {{')
        else:
            # Equality/Inequality
            if is_numeric:
                # Direct float comparison
                dst.append(f'{indent}  if ({val_expr} {cond_op} {cond_state}) {{')
            else:
                # String comparison for text sensors
                if cond_op == "==":
                    dst.append(f'{indent}  if (id({safe_cond_id}).state == "{cond_state}") {{')
                else:
                    dst.append(f'{indent}  if (id({safe_cond_id}).state != "{cond_state}") {{')

    # Content needs extra indent
    indented_content = [line.replace(indent, indent + "    ", 1) if line.startswith(indent) else "    " + line for line in content_lines]
    dst.extend(indented_content)
    
    dst.append(f'{indent}  }}')
    dst.append(f'{indent}}}')


def _append_widget_render(dst: List[str], indent: str, widget: WidgetConfig, numeric_entity_ids: dict[str, int]) -> None:
    """Render a single widget into display lambda C++ code.

    Unified styling semantics:
    - type: "text" / "label"
    - type: "sensor" / "sensor_text"
    - type: "datetime"
    - type: "progress_bar"
    - type: "battery_icon"
    - type: "shape_rect"
    - type: "shape_circle"
    - type: "line"
    - type: "image"
    - type: "history"
    
    Supports conditional visibility based on entity state.
    """
    # ============================================================================
    # CRITICAL: Widget coordinate clamping
    # DO NOT CHANGE: Clamps widget positions to canvas bounds (800x480)
    # These clamped values are written to YAML markers and must be parsed back exactly
    # ============================================================================
    x = max(0, min(widget.x, IMAGE_WIDTH))
    y = max(0, min(widget.y, IMAGE_HEIGHT))
    w = max(1, min(widget.width, IMAGE_WIDTH - x))
    h = max(1, min(widget.height, IMAGE_HEIGHT - y))
    
    wtype = (widget.type or "text").lower()
    
    _LOGGER.debug(f"Generating widget {widget.id} type={wtype} x={widget.x}→{x} y={widget.y}→{y} w={widget.width}→{w} h={widget.height}→{h}")
    props = widget.props or {}

    # Determine base color polarity from props.color and invert.
    base_color = (props.get("color") or "").lower()
    # E-Paper: COLOR_ON = black ink, COLOR_OFF = white (no ink)
    if base_color == "white":
        fg = "COLOR_OFF"  # White = no ink
    elif base_color == "gray":
        # For grayscale we still use black ink; left for future patterns.
        fg = "COLOR_ON"
    else:
        # Default to black ink
        fg = "COLOR_ON"

    if props.get("invert"):
        fg = "COLOR_OFF" if fg == "COLOR_ON" else "COLOR_ON"

    # Collect widget rendering code, then wrap with condition if needed
    content: List[str] = []

    # Floating text (no box)
    if wtype in ("label", "text"):
        text = (props.get("text") or widget.title or "").replace('"', '\\"')
        if not text:
            return
        font = _resolve_font(props)
        font_size = int(props.get("font_size", 12) or 12)
        font_family = props.get("font_family") or "Inter"
        color_prop = (props.get("color") or "black").lower()
        font_style = props.get("font_style") or "regular"
        font_weight = int(props.get("font_weight", 400) or 400)
        # Add marker comment for parser with all properties including font_family and font_weight
        content.append(f'{indent}// widget:text id:{widget.id} type:text x:{x} y:{y} w:{w} h:{h} text:"{text}" font_size:{font_size} font_family:{font_family} font_weight:{font_weight} weight:{font_weight} color:{color_prop} font_style:{font_style}')
        content.append(f'{indent}it.print({x}, {y}, {font}, {fg}, "{text}");')
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Icon widget (MDI icon from font)
    if wtype == "icon":
        code = (props.get("code") or "F0595").strip().upper()
        # Validate code format (Fxxx)
        if not code.startswith("F") or len(code) != 5:
            code = "F0595"  # Default to weather-cloudy
        # Convert to unicode codepoint
        try:
            hex_val = int(code[1:], 16)
            codepoint = 0xF0000 + hex_val
            icon_char = chr(codepoint)
        except (ValueError, OverflowError):
            icon_char = chr(0xF0595)  # Fallback
        
        # Determine font based on size - always use size-specific ID
        size = int(props.get("size", 48) or 48)
        font_id = f"font_mdi_{size}"
        
        # Always use the calculated font_id, ignore any stored font_ref (could be outdated)
        font_ref = font_id
        
        # Handle color property - icon widgets have their own color, don't use base fg
        color_prop = (props.get("color") or "black").lower()
        if color_prop == "white":
            icon_color = "COLOR_OFF"
        elif color_prop == "gray":
            icon_color = "COLOR_ON"  # E-paper doesn't have gray, use black
        else:  # black or default
            icon_color = "COLOR_ON"
        
        # Escape special characters
        escaped_char = icon_char.replace("\\", "\\\\").replace('"', '\\"')
        # Add marker comment for parser
        content.append(f'{indent}// widget:icon id:{widget.id} type:icon x:{x} y:{y} w:{w} h:{h} code:{code} size:{size} color:{color_prop}')
        content.append(f'{indent}it.print({x}, {y}, id({font_ref}), {icon_color}, "{escaped_char}");')
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Sensor text (label + value from HA sensor)
    if wtype in ("sensor", "sensor_text"):
        entity_id = (widget.entity_id or "").strip()
        label = (widget.title or "").replace('"', '\\"')
        value_format = props.get("value_format", "label_value")
        label_font_size = int(props.get("label_font_size", 14) or 14)
        value_font_size = int(props.get("value_font_size", 20) or 20)
        font_family = props.get("font_family") or "Inter"
        font_weight = int(props.get("font_weight", 400) or 400)
        precision = int(props.get("precision", -1))
        
        if entity_id:
            # Generate safe ID from entity_id (handle local vs HA)
            if "." in entity_id:
                safe_id = entity_id.replace(".", "_").replace("-", "_")
            else:
                safe_id = entity_id
            
            # Determine if entity is numeric
            is_numeric = entity_id in numeric_entity_ids
            # Force text mode if explicitly requested
            if props.get("is_text_sensor"):
                is_numeric = False
                
            # Format string and value expression
            unit = props.get("unit", "")
            if is_numeric:
                precision = int(props.get("precision", -1))
                if precision < 0:
                    fmt = "%.1f"
                else:
                    fmt = f"%.{precision}f"
                val_expr = f"id({safe_id}).state"
            else:
                fmt = "%s"
                val_expr = f"id({safe_id}).state.c_str()"
                
            # Add marker comment for parser
            # CRITICAL: Parser depends on exact format
            is_local = "true" if props.get("is_local_sensor") else "false"
            is_text = "true" if not is_numeric else "false"
            text_align = props.get("text_align", "TOP_LEFT").upper()
            
            label_font = _resolve_font_by_size(label_font_size, font_weight)
            value_font = _resolve_font_by_size(value_font_size, font_weight)

            content.append(f'{indent}// widget:sensor_text id:{widget.id} type:sensor_text x:{x} y:{y} w:{w} h:{h} ent:{entity_id} title:"{label}" format:{value_format} label_font:{label_font_size} value_font:{value_font_size} color:{base_color} align:{text_align} precision:{props.get("precision", -1)} unit:"{unit}" local:{is_local} text_sensor:{is_text}')

            if value_format == "label_newline_value" and label:
                # Label on top, value below
                content.append(f'{indent}it.printf({x}, {y}, {label_font}, {fg}, TextAlign::{text_align}, "{label}");')
                # Value below label
                content.append(f'{indent}it.printf({x}, {y} + {label_font_size} + 2, {value_font}, {fg}, TextAlign::{text_align}, "{fmt}%s", {val_expr}, "{unit}");')
            elif value_format == "label_value" and label:
                # Inline format: "Label: Value"
                content.append(f'{indent}it.printf({x}, {y}, {value_font}, {fg}, TextAlign::{text_align}, "{label}: {fmt}%s", {val_expr}, "{unit}");')
            else:
                # value_only or no label - just show value
                font = _resolve_font_by_size(value_font_size, font_weight)
                content.append(f'{indent}it.printf({x}, {y}, {font}, {fg}, "{fmt_spec}", {val_expr});')
        else:
            # No entity_id configured - show placeholder
            placeholder = label or "sensor"
            font = _resolve_font_by_size(value_font_size, font_weight)
            # Add marker comment for parser with font sizes and font_family
            content.append(f'{indent}// widget:sensor_text id:{widget.id} type:sensor_text x:{x} y:{y} w:{w} h:{h} title:"{label}" label_font:{label_font_size} value_font:{value_font_size} format:{value_format} font_family:{font_family} font_weight:{font_weight} precision:{precision}')
            content.append(f'{indent}// No entity_id configured for this sensor_text widget')
            content.append(f'{indent}it.printf({x}, {y}, {font}, {fg}, "{placeholder}: N/A");')
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Date/time widget
    if wtype == "datetime":
        format_type = props.get("format", "time_date")
        time_font_size = int(props.get("time_font_size", 28) or 28)
        date_font_size = int(props.get("date_font_size", 16) or 16)
        
        time_font = _resolve_font_by_size(time_font_size, 700)
        date_font = _resolve_font_by_size(date_font_size, 400)
        
        # Calculate center X for alignment
        cx = x + w // 2
        
        # Extract font_family for marker (even though datetime currently doesn't use it for rendering)
        font_family = props.get("font_family") or "Inter"
        
        # Add marker comment for parser
        content.append(f'{indent}// widget:datetime id:{widget.id} type:datetime x:{x} y:{y} w:{w} h:{h} format:{format_type} time_font:{time_font_size} date_font:{date_font_size} color:{base_color} font_family:{font_family}')
        
        if format_type == "time_only":
            # Time only - centered
            content.append(f'{indent}it.strftime({cx}, {y}, {time_font}, {fg}, TextAlign::TOP_CENTER, "%H:%M", id(ha_time).now());')
        elif format_type == "date_only":
            # Date only - centered
            content.append(f'{indent}it.strftime({cx}, {y}, {date_font}, {fg}, TextAlign::TOP_CENTER, "%a, %b %d", id(ha_time).now());')
        else:
            # time_date - time on top, date below
            content.append(f'{indent}it.strftime({cx}, {y}, {time_font}, {fg}, TextAlign::TOP_CENTER, "%H:%M", id(ha_time).now());')
            date_y = y + time_font_size + 4
            content.append(f'{indent}it.strftime({cx}, {date_y}, {date_font}, {fg}, TextAlign::TOP_CENTER, "%a, %b %d", id(ha_time).now());')
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Progress bar widget
    if wtype == "progress_bar":
        entity_id = (widget.entity_id or "").strip()
        label = (widget.title or "").replace('"', '\\"')
        show_label = props.get("show_label", True)
        show_percentage = props.get("show_percentage", True)
        bar_height = int(props.get("bar_height", 15) or 15)
        border_width = int(props.get("border_width", 1) or 1)
        
        show_label_str = "true" if show_label else "false"
        show_pct_str = "true" if show_percentage else "false"
        is_local = "true" if props.get("is_local_sensor") else "false"

        if not entity_id:
            # No entity configured - show placeholder
            # CRITICAL: Must include coordinates even if no entity, otherwise parser defaults to 40,40
            # Also include style properties so they persist
            content.append(f'{indent}// widget:progress_bar id:{widget.id} type:progress_bar x:{x} y:{y} w:{w} h:{h} label:"{label}" bar_height:{bar_height} border:{border_width} show_label:{show_label_str} show_pct:{show_pct_str} color:{base_color} (no entity configured)')
            content.append(f'{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});')
            _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
            return
        
        # Generate safe ID from entity_id (handle local vs HA)
        if "." in entity_id:
            safe_id = entity_id.replace(".", "_").replace("-", "_")
        else:
            safe_id = entity_id
        
        # ============================================================================
        # CRITICAL: Progress bar marker comment format
        # DO NOT CHANGE: Parser depends on exact format: x:{x} y:{y} w:{w} h:{h}
        # These coordinates must be preserved for round-trip editing to work
        # ============================================================================
        content.append(f'{indent}// widget:progress_bar id:{widget.id} type:progress_bar x:{x} y:{y} w:{w} h:{h} ent:{entity_id} title:"{label}" show_label:{show_label_str} show_pct:{show_pct_str} bar_h:{bar_height} border_w:{border_width} color:{base_color} local:{is_local}')
        
        # Calculate vertical layout
        label_y = y
        bar_y = y
        
        if show_label and (label or show_percentage):
            # Label/percentage row at top
            if label and show_percentage:
                # Both label and percentage
                label_font = _resolve_font_by_size(12)
                content.append(f'{indent}it.printf({x}, {label_y}, {label_font}, {fg}, "{label}");')
                # Percentage on the right
                content.append(f'{indent}it.printf({x}+{w}-30, {label_y}, {label_font}, {fg}, "%.0f%%", id({safe_id}).state);')
            elif label:
                # Label only
                label_font = _resolve_font_by_size(12)
                content.append(f'{indent}it.printf({x}, {label_y}, {label_font}, {fg}, "{label}");')
            elif show_percentage:
                # Percentage only
                label_font = _resolve_font_by_size(12)
                content.append(f'{indent}it.printf({x}, {label_y}, {label_font}, {fg}, "%.0f%%", id({safe_id}).state);')
            
            bar_y = label_y + 16
        
        # Draw progress bar border
        content.append(f'{indent}it.rectangle({x}, {bar_y}, {w}, {bar_height}, {fg});')
        
        # Draw progress bar fill (clamp to 0-100%)
        content.append(f'{indent}// Fill progress bar based on sensor value (0-100%)')
        content.append(f'{indent}{{')
        content.append(f'{indent}  float progress = id({safe_id}).state;')
        content.append(f'{indent}  if (progress < 0) progress = 0;')
        content.append(f'{indent}  if (progress > 100) progress = 100;')
        content.append(f'{indent}  int fill_width = (int)(({w} - 2) * (progress / 100.0));')
        content.append(f'{indent}  if (fill_width > 0) {{')
        content.append(f'{indent}    it.filled_rectangle({x}+1, {bar_y}+1, fill_width, {bar_height}-2, {fg});')
        content.append(f'{indent}  }}')
        content.append(f'{indent}}}')
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Battery icon widget - dynamic icon based on battery level
    if wtype == "battery_icon":
        entity_id = (widget.entity_id or "").strip()
        size = int(props.get("size", 48) or 48)
        font_id = f"font_mdi_{size}"
        
        if not entity_id:
            # No entity configured - show static battery icon
            # CRITICAL: Must include coordinates even if no entity, otherwise parser defaults to 40,40
            # Also include size so it persists
            content.append(f'{indent}// widget:battery_icon id:{widget.id} type:battery_icon x:{x} y:{y} w:{w} h:{h} size:{size} color:{base_color} (no entity configured)')
            content.append(f'{indent}it.printf({x}, {y}, id({font_id}), {fg}, "\\U000F0079");  // battery')
            _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
            return
        
        # Generate safe ID from entity_id (handle local vs HA)
        if "." in entity_id:
            safe_id = entity_id.replace(".", "_").replace("-", "_")
        else:
            safe_id = entity_id
        
        # ============================================================================
        # CRITICAL: Battery icon marker comment format
        # DO NOT CHANGE: Parser depends on exact format: x:{x} y:{y} w:{w} h:{h}
        # These coordinates must be preserved for round-trip editing to work
        # ============================================================================
        is_local = "true" if props.get("is_local_sensor") else "false"
        content.append(f'{indent}// widget:battery_icon id:{widget.id} type:battery_icon x:{x} y:{y} w:{w} h:{h} ent:{entity_id} size:{size} color:{base_color} local:{is_local}')
        
        # Add logic to pick battery icon based on level
        content.append(f'{indent}{{')
        content.append(f'{indent}  float level = id({safe_id}).state;')
        content.append(f'{indent}  const char* icon;')
        content.append(f'{indent}  if (level <= 10)      icon = "\\U000F007A";  // battery-10')
        content.append(f'{indent}  else if (level <= 20) icon = "\\U000F007B";  // battery-20')
        content.append(f'{indent}  else if (level <= 30) icon = "\\U000F007C";  // battery-30')
        content.append(f'{indent}  else if (level <= 40) icon = "\\U000F007D";  // battery-40')
        content.append(f'{indent}  else if (level <= 50) icon = "\\U000F007E";  // battery-50')
        content.append(f'{indent}  else if (level <= 60) icon = "\\U000F007F";  // battery-60')
        content.append(f'{indent}  else if (level <= 70) icon = "\\U000F0080";  // battery-70')
        content.append(f'{indent}  else if (level <= 80) icon = "\\U000F0081";  // battery-80')
        content.append(f'{indent}  else if (level <= 90) icon = "\\U000F0082";  // battery-90')
        content.append(f'{indent}  else                  icon = "\\U000F0079";  // battery (full)')
        content.append(f'{indent}  it.printf({x}, {y}, id({font_id}), {fg}, "%s", icon);')
        content.append(f'{indent}  // Show percentage below icon')
        content.append(f'{indent}  it.printf({x}, {y}+{size}+2, id(font_small), {fg}, "%.0f%%", level);')
        content.append(f'{indent}}}')
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Weather icon widget - dynamic icon based on weather state
    if wtype == "weather_icon":
        entity_id = (widget.entity_id or "").strip()
        size = int(props.get("size", 48) or 48)
        font_id = f"font_mdi_{size}"
        
        if not entity_id:
            content.append(f'{indent}// widget:weather_icon id:{widget.id} type:weather_icon x:{x} y:{y} w:{w} h:{h} size:{size} color:{base_color} (no entity)')
            content.append(f'{indent}it.printf({x}, {y}, id({font_id}), {fg}, "\\U000F0591"); // sunny placeholder')
            _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
            return

        if "." in entity_id:
            safe_id = entity_id.replace(".", "_").replace("-", "_")
        else:
            safe_id = entity_id
            
        content.append(f'{indent}// widget:weather_icon id:{widget.id} type:weather_icon x:{x} y:{y} w:{w} h:{h} ent:{entity_id} size:{size} color:{base_color}')
        
        # Generate C++ lambda to map weather state to icon
        content.append(f'{indent}{{')
        content.append(f'{indent}  std::string state = id({safe_id}).state;')
        content.append(f'{indent}  const char* icon = "\\U000F0591"; // default sunny')
        content.append(f'{indent}  if (state == "clear-night") icon = "\\U000F0594";')
        content.append(f'{indent}  else if (state == "cloudy") icon = "\\U000F0595";')
        content.append(f'{indent}  else if (state == "fog") icon = "\\U000F192C";')
        content.append(f'{indent}  else if (state == "hail") icon = "\\U000F0E6E";')
        content.append(f'{indent}  else if (state == "lightning") icon = "\\U000F0598";')
        content.append(f'{indent}  else if (state == "lightning-rainy") icon = "\\U000F067F";')
        content.append(f'{indent}  else if (state == "partlycloudy") icon = "\\U000F0599";')
        content.append(f'{indent}  else if (state == "pouring") icon = "\\U000F06A1";')
        content.append(f'{indent}  else if (state == "rainy") icon = "\\U000F0596";')
        content.append(f'{indent}  else if (state == "snowy") icon = "\\U000F0590";')
        content.append(f'{indent}  else if (state == "snowy-rainy") icon = "\\U000F0F32";')
        content.append(f'{indent}  else if (state == "sunny") icon = "\\U000F0591";')
        content.append(f'{indent}  else if (state == "windy") icon = "\\U000F0597";')
        content.append(f'{indent}  else if (state == "windy-variant") icon = "\\U000F0F2F";')
        content.append(f'{indent}  else if (state == "exceptional") icon = "\\U000F0024";')
        content.append(f'{indent}  it.printf({x}, {y}, id({font_id}), {fg}, "%s", icon);')
        content.append(f'{indent}}}')
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Rectangle / filled rectangle
    if wtype == "shape_rect":
        fill = bool(props.get("fill"))
        border_width = int(props.get("border_width", 1) or 1)
        opacity = int(props.get("opacity", 100) or 100)
        
        # Add marker comment for parser
        fill_str = "true" if fill else "false"
        content.append(f'{indent}// widget:shape_rect id:{widget.id} type:shape_rect x:{x} y:{y} w:{w} h:{h} fill:{fill_str} border:{border_width} opacity:{opacity} color:{base_color}')
        
        # Check if we should use grey dithering pattern (50% checkerboard)
        use_grey_pattern = (base_color == "gray" and fill)
        
        if fill:
            if use_grey_pattern:
                # Grey: create 50% checkerboard pattern for visual distinction from solid black
                content.append(f"{indent}// Opaque Grey fill using 50% checkerboard dithering pattern")
                content.append(f"{indent}for (int dy = 0; dy < {h}; dy++) {{")
                content.append(f"{indent}  for (int dx = 0; dx < {w}; dx++) {{")
                content.append(f"{indent}    if ((dx + dy) % 2 == 0) {{")
                content.append(f"{indent}      it.draw_pixel_at({x}+dx, {y}+dy, COLOR_ON);")
                content.append(f"{indent}    }} else {{")
                content.append(f"{indent}      it.draw_pixel_at({x}+dx, {y}+dy, COLOR_OFF);")
                content.append(f"{indent}    }}")
                content.append(f"{indent}  }}")
                content.append(f"{indent}}}")
            elif opacity < 100:
                # Opacity simulation using dithering
                # Simple dithering: skip pixels based on opacity
                # 75% opacity = draw 3/4 pixels
                # 50% opacity = draw 1/2 pixels (checkerboard)
                # 25% opacity = draw 1/4 pixels
                content.append(f"{indent}// Opacity {opacity}% simulation")
                content.append(f"{indent}for (int dy = 0; dy < {h}; dy++) {{")
                content.append(f"{indent}  for (int dx = 0; dx < {w}; dx++) {{")
                threshold = int(opacity * 2.55) # Map 0-100 to 0-255
                # Use a simple pseudo-random or pattern based check
                # (dx*3 + dy*7) % 100 < opacity
                content.append(f"{indent}    if (((dx*3 + dy*7) % 100) < {opacity}) {{")
                content.append(f"{indent}      it.draw_pixel_at({x}+dx, {y}+dy, {fg});")
                content.append(f"{indent}    }}")
                content.append(f"{indent}  }}")
                content.append(f"{indent}}}")
            else:
                # Solid fill (black or white)
                content.append(f"{indent}it.filled_rectangle({x}, {y}, {w}, {h}, {fg});")
            if border_width > 1:
                content.append(f"{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});")
        else:
            if border_width <= 1:
                content.append(f"{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});")
            else:
                # Approximate thicker border using multiple rectangles.
                content.append(f"{indent}// rectangle with border_width={border_width}")
                content.append(f"{indent}for (int i = 0; i < {border_width}; i++) {{")
                content.append(
                    f"{indent}  it.rectangle({x}+i, {y}+i, {w}-2*i, {h}-2*i, {fg});"
                )
                content.append(f"{indent}}}")
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return



    # Circle / filled circle (use width/height box)
    if wtype == "shape_circle":
        # Revert to simple circle logic (no ellipse support in ESPHome display)
        # Use the smaller dimension to ensure it fits
        r = min(w, h) // 2
        cx = x + (w // 2)
        cy = y + (h // 2)
        fill = bool(props.get("fill"))
        border_width = int(props.get("border_width", 1) or 1)
        opacity = int(props.get("opacity", 100) or 100)
        
        # Add marker comment for parser
        fill_str = "true" if fill else "false"
        content.append(f'{indent}// widget:shape_circle id:{widget.id} type:shape_circle x:{x} y:{y} w:{w} h:{h} fill:{fill_str} border:{border_width} opacity:{opacity} color:{base_color}')
        
        # Check if we should use grey dithering pattern
        use_grey_pattern = (base_color == "gray" and fill)
        
        if fill:
            if use_grey_pattern:
                # Grey: create 50% checkerboard pattern within circle
                content.append(f"{indent}// Opaque Grey fill using 50% checkerboard dithering pattern")
                content.append(f"{indent}for (int dy = -{r}; dy <= {r}; dy++) {{")
                content.append(f"{indent}  for (int dx = -{r}; dx <= {r}; dx++) {{")
                content.append(f"{indent}    if (dx*dx + dy*dy <= {r}*{r}) {{")
                content.append(f"{indent}      if ((dx + dy) % 2 == 0) {{")
                content.append(f"{indent}        it.draw_pixel_at({cx}+dx, {cy}+dy, COLOR_ON);")
                content.append(f"{indent}      }} else {{")
                content.append(f"{indent}        it.draw_pixel_at({cx}+dx, {cy}+dy, COLOR_OFF);")
                content.append(f"{indent}      }}")
                content.append(f"{indent}    }}")
                content.append(f"{indent}  }}")
                content.append(f"{indent}}}")
            elif opacity < 100:
                # Opacity simulation
                content.append(f"{indent}// Opacity {opacity}% simulation")
                content.append(f"{indent}for (int dy = -{r}; dy <= {r}; dy++) {{")
                content.append(f"{indent}  for (int dx = -{r}; dx <= {r}; dx++) {{")
                content.append(f"{indent}    if (dx*dx + dy*dy <= {r}*{r}) {{")
                content.append(f"{indent}      if (((dx*3 + dy*7) % 100) < {opacity}) {{")
                content.append(f"{indent}        it.draw_pixel_at({cx}+dx, {cy}+dy, {fg});")
                content.append(f"{indent}      }}")
                content.append(f"{indent}    }}")
                content.append(f"{indent}  }}")
                content.append(f"{indent}}}")
            else:
                # Solid fill
                content.append(f"{indent}it.filled_circle({cx}, {cy}, {r}, {fg});")
            
            if border_width > 1:
                content.append(f"{indent}it.circle({cx}, {cy}, {r}, {fg});")
        else:
            if border_width <= 1:
                content.append(f"{indent}it.circle({cx}, {cy}, {r}, {fg});")
            else:
                content.append(f"{indent}// border_width={border_width}")
                content.append(f"{indent}for (int i = 0; i < {border_width}; i++) {{")
                content.append(f"{indent}  it.circle({cx}, {cy}, {r}-i, {fg});")
                content.append(f"{indent}}}")
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Line: from (x,y) to (x+width,y+height) using width/height as dx/dy
    if wtype == "line":
        dx = w
        dy = h
        stroke_width = int(props.get("stroke_width", 1) or 1)
        # Add marker comment for parser
        content.append(f'{indent}// widget:line id:{widget.id} type:line x:{x} y:{y} w:{w} h:{h} stroke:{stroke_width} color:{base_color}')
        content.append(f"{indent}it.line({x}, {y}, {x}+{dx}, {y}+{dy}, {fg});")
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Graph widget
    if wtype == "graph":
        entity_id = (widget.entity_id or "").strip()
        duration = props.get("duration", "1h")
        border = bool(props.get("border", True))
        color_prop = (props.get("color") or "black").lower()
        title = (widget.title or "").replace('"', '\\"')
        
        # Additional graph props for persistence
        x_grid = props.get("x_grid", "")
        y_grid = props.get("y_grid", "")
        line_type = props.get("line_type", "")
        line_thickness = props.get("line_thickness", "")
        min_value = props.get("min_value", "")
        max_value = props.get("max_value", "")
        min_range = props.get("min_range", "")
        max_range = props.get("max_range", "")
        continuous = "true" if props.get("continuous") else "false"
        is_local = "true" if props.get("is_local_sensor") else "false"
        
        safe_id = f"graph_{widget.id}".replace("-", "_")

        if not entity_id:
            content.append(f'{indent}// widget:graph id:{widget.id} type:graph x:{x} y:{y} w:{w} h:{h} duration:"{duration}" border:{border} color:{color_prop} title:"{title}" (no entity)')
            content.append(f'{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});')
            content.append(f'{indent}it.line({x}, {y}+{h}, {x}+{w}, {y}, {fg});')
            content.append(f'{indent}it.printf({x}+5, {y}+5, id(font_small), {fg}, "Graph (no entity)");')
        else:
            show_axis_labels = "true" if props.get("show_axis_labels") else "false"
            content.append(f'{indent}// widget:graph id:{widget.id} type:graph x:{x} y:{y} w:{w} h:{h} entity:"{entity_id}" duration:"{duration}" border:"{border}" color:"{color_prop}" x_grid:"{x_grid}" y_grid:"{y_grid}" line_type:"{line_type}" line_thickness:"{line_thickness}" min_value:"{min_value}" max_value:"{max_value}" min_range:"{min_range}" max_range:"{max_range}" continuous:"{continuous}" local:"{is_local}" title:"{title}" show_axis_labels:"{show_axis_labels}"')
            content.append(f'{indent}it.graph({x}, {y}, id({safe_id}));')
            
            # Render title if present
            if title:
                # Draw title in top-left corner with small font
                content.append(f'{indent}it.printf({x}+4, {y}+2, id(font_small), {fg}, "{title}");')

            # Render Axis Labels if enabled and min/max are set
            if props.get("show_axis_labels") and min_value and max_value:
                # Smart Positioning: Flip Y-axis labels if too close to left edge
                flip_y = x < 30
                
                # Y-Axis Labels
                if flip_y:
                    # Right side
                    content.append(f'{indent}it.printf({x}+{w}+2, {y}-6, id(font_axis), {fg}, TextAlign::TOP_LEFT, "{max_value}");')
                    content.append(f'{indent}it.printf({x}+{w}+2, {y}+{h}-6, id(font_axis), {fg}, TextAlign::BOTTOM_LEFT, "{min_value}");')
                else:
                    # Left side
                    content.append(f'{indent}it.printf({x}-2, {y}-6, id(font_axis), {fg}, TextAlign::TOP_RIGHT, "{max_value}");')
                    content.append(f'{indent}it.printf({x}-2, {y}+{h}-6, id(font_axis), {fg}, TextAlign::BOTTOM_RIGHT, "{min_value}");')
                
                # X-Axis Labels
                # Start (Duration)
                content.append(f'{indent}it.printf({x}, {y}+{h}+2, id(font_axis), {fg}, TextAlign::TOP_LEFT, "-{duration}");')
                # End (Now)
                content.append(f'{indent}it.printf({x}+{w}, {y}+{h}+2, id(font_axis), {fg}, TextAlign::TOP_RIGHT, "Now");')

        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Image widget
    if wtype == "image":
        path = (props.get("path") or "").strip()
        invert = bool(props.get("invert"))
        
        if path:
            # Generate safe ID from path (same logic as in _generate_fonts)
            safe_path = path.replace("/", "_").replace(".", "_").replace("-", "_").replace(" ", "_")
            # IMPORTANT: Include dimensions in ID to match the definition in _generate_fonts
            safe_id = f"img_{safe_path}_{w}x{h}"
            
            # Add marker comment for parser
            content.append(f'{indent}// widget:image id:{widget.id} type:image x:{x} y:{y} w:{w} h:{h} path:"{path}" invert:{invert}')
            
            if invert:
                content.append(f"{indent}it.image({x}, {y}, id({safe_id}), COLOR_OFF, COLOR_ON);")
            else:
                content.append(f"{indent}it.image({x}, {y}, id({safe_id}));")
        else:
            content.append(f'{indent}// widget:image id:{widget.id} type:image x:{x} y:{y} w:{w} h:{h} (no path)')
            content.append(f'{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});')
            
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # History widget: placeholder visualization; requires precomputed entity
    if wtype == "history":
        entity_id = (props.get("entity_id") or widget.entity_id or "").replace('"', '\\"')
        style = (props.get("style") or "bars").lower()
        label = entity_id or "history"
        font = _resolve_font(props)
        content.append(f"{indent}// history widget for {entity_id}; expects external aggregation")
        content.append(f'{indent}it.print({x}, {y}, {font}, {fg}, "{label}");')
        # Simple placeholder box/lines
        hx = x
        hy = y + 14
        hw = max(10, w)
        hh = max(6, h - 16)
        content.append(f"{indent}it.rectangle({hx}, {hy}, {hw}, {hh}, {fg});")
        if style == "line":
            content.append(f"{indent}it.line({hx+2}, {hy+hh-3}, {hx+hw-2}, {hy+3}, {fg});")
        else:
            content.append(f"{indent}// draw simple bar-style segments as placeholder")
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Online Image widget
    if wtype == "online_image":
        url = (props.get("url") or "").strip()
        safe_id = f"img_{widget.id}".replace("-", "_")
        content.append(f'{indent}// widget:online_image id:{widget.id} type:online_image x:{x} y:{y} w:{w} h:{h} url:"{url}"')
        content.append(f"{indent}it.image({x}, {y}, id({safe_id}));")
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Puppet widget (online image wrapper)
    if wtype == "puppet":
        url = (props.get("image_url") or "").strip()
        safe_id = f"img_{widget.id}".replace("-", "_")
        content.append(f'{indent}// widget:puppet id:{widget.id} type:puppet x:{x} y:{y} w:{w} h:{h} url:"{url}"')
        content.append(f"{indent}it.image({x}, {y}, id({safe_id}));")
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Unknown type: emit comment for safety
    dst.append(f'{indent}// TODO: unsupported widget type "{widget.type}" at ({x},{y})')
