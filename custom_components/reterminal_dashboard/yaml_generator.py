"""
YAML snippet generator for the reTerminal Dashboard Designer integration.

This module takes the internal layout model (DeviceConfig / PageConfig / WidgetConfig)
and produces ESPHome-compatible YAML snippets that the user can paste BELOW an
existing base ESPHome config.

Key principles:
- We DO NOT emit:
  - esphome:
  - esp32:
  - wifi:
  - api:
  - ota:
  - logger:
- We ONLY emit additive blocks:
  - globals, fonts, outputs, rtttl, sensors, text_sensors, scripts, display, etc.
- We target the reTerminal E1001 epaper (800x480) as the initial device.

The output is a single YAML snippet string containing:
- Header comments explaining how to use it.
- Behavior/config blocks (buttons, scripts, etc).
- Layout block(s) mapping configured pages/widgets to display lambda code.

NOTE: This is an MVP generator:
- Focus on safe, deterministic output.
- Supports a conservative subset of widget types.
- Uses IDs and structures inspired by the working reference in:
  resources/ESPHome Reterminal/reterminalE-1001-esphome.txt
"""

from __future__ import annotations

import logging
from typing import List

from .models import DeviceConfig, PageConfig, WidgetConfig
from .const import IMAGE_WIDTH, IMAGE_HEIGHT

_LOGGER = logging.getLogger(__name__)


SNIPPET_HEADER = """# ============================================================
# Generated by reTerminal Dashboard Designer
# Target device: reTerminal E1001 (800x480 epaper)
#
# Usage:
# 1. Ensure you already have a working base ESPHome config for your device:
#    - Includes: esphome, esp32, wifi, api, ota, logger
#    - Uses the correct board for the reTerminal E1001
#    - CRITICAL: Add 'compile_process_limit: 1' to your 'esphome:' section
#      to prevent Out-Of-Memory errors during compilation!
# 2. Paste this snippet BELOW your existing base config.
# 3. Do NOT duplicate esphome:, wifi:, api:, ota:, logger: sections.
# 4. If you already define conflicting ids (e.g. epaper_display), adjust accordingly.
#
# WARNING:
# - This is an MVP generator. Review the result before flashing.
# - Keep this snippet under version control to track your layout changes.
# ============================================================
"""


def generate_snippet(device: DeviceConfig) -> str:
    """
    Generate a complete YAML snippet for the given device configuration.

    The snippet includes:
    - Required globals/fonts/outputs/rtttl/buttons/sensors/scripts for navigation.
    - A display: epaper_display block with lambda that renders all pages/widgets.

    This function assumes:
    - Single device_type: reTerminal E1001.
    - IMAGE_WIDTH/IMAGE_HEIGHT match the target display (800x480).
    """
    device.ensure_pages()

    parts: List[str] = [SNIPPET_HEADER.rstrip(), ""]

    # Core pieces (ordered for readability)
    # NOTE: output, rtttl, sensor, time are provided by hardware template
    # We only generate: globals, fonts, text_sensor, button, script, display
    
    # Pre-classify entities to determine numeric vs text vs local
    text_entity_ids, numeric_entity_ids, local_entity_ids = _classify_entities(device)
    
    # STEP 1: Generate display block FIRST (this contains all the font references)
    display_block = _generate_display_block(device, numeric_entity_ids)
    
    # STEP 2: Parse the display block to extract which fonts are actually used
    fonts_used = _extract_fonts_from_display_code(display_block)
    
    # STEP 3: Generate font definitions for only the fonts that were referenced
    parts.append(_generate_globals())
    parts.append(_generate_fonts_from_usage(device, fonts_used))
    parts.append(_generate_text_sensors(device, text_entity_ids, numeric_entity_ids, local_entity_ids))
    parts.append(_generate_online_images(device))
    parts.append(_generate_deep_sleep(device))
    parts.append(_generate_scripts(device))
    parts.append(_generate_graphs(device))
    parts.append(display_block)

    # Join with double newlines between major sections
    return "\n\n".join(p for p in parts if p.strip())


def _extract_fonts_from_display_code(display_code: str) -> dict:
    """
    Parse the generated display lambda code to extract all font references.
    Returns a dict with text_fonts and icon_fonts that were actually used.
    
    This is the BULLETPROOF approach - we parse exactly what's in the generated code,
    so there's no possibility of mismatch between font references and font definitions.
    """
    import re
    
    fonts_used = {
        'text_fonts': {},  # {(family, weight, size): {'dynamic': True, 'chars': set()}}
        'icon_fonts_by_size': {}  # {size: set_of_glyph_codes}
    }
    
    # Pattern to match text font references: id(font_inter_400_14) or id(font_roboto_900_100)
    text_font_pattern = r'id\(font_([a-z_]+)_(\d+)_(\d+)\)'
    text_matches = re.findall(text_font_pattern, display_code)
    
    for family_id, weight, size in text_matches:
        # Convert family_id back to proper case (inter -> Inter, roboto -> Roboto)
        family = family_id.replace('_', ' ').title().replace(' ', '')
        if family.lower() == 'roboto':
            family = 'Roboto'
        elif family.lower() == 'inter':
            family = 'Inter'
        
        key = (family, int(weight), int(size))
        if key not in fonts_used['text_fonts']:
            # Mark as dynamic since we can't tell from the code alone
            fonts_used['text_fonts'][key] = {'dynamic': True, 'chars': set()}
    
    # Pattern to match icon font references: id(font_mdi_48) or id(font_mdi_249)
    icon_font_pattern = r'id\(font_mdi_(\d+)\)'
    icon_matches = re.findall(icon_font_pattern, display_code)
    
    for size_str in icon_matches:
        size = int(size_str)
        if size not in fonts_used['icon_fonts_by_size']:
            fonts_used['icon_fonts_by_size'][size] = set()
        # We'll need to extract actual glyphs used later, for now just mark the size
    
    _LOGGER.info(f"Extracted fonts from display code: {len(fonts_used['text_fonts'])} text fonts, {len(fonts_used['icon_fonts_by_size'])} icon font sizes")
    
    return fonts_used


def _generate_globals() -> str:
    return ""


def _generate_deep_sleep(device: DeviceConfig) -> str:
    """
    Generate deep_sleep configuration for power saving.
    """
    if not device.deep_sleep_enabled:
        return ""

    # run_duration: 30s gives enough time to connect, fetch time/sensors, and render.
    # sleep_duration: user configured interval.
    return f"""deep_sleep:
  id: deep_sleep_1
  run_duration: 30s
  sleep_duration: {device.deep_sleep_interval}s
"""




def _generate_fonts_from_usage(device: DeviceConfig, fonts_used: dict) -> str:
    """
    Generate font definitions based on fonts extracted from the display code.
    This ensures we only generate fonts that are actually referenced.
    
    Also collects icon glyphs from widgets to populate the MDI fonts.
    """
    # Extract icon glyphs from widgets (we still need this since display code doesn't contain the actual Unicode chars)
    icon_glyphs_by_size = {}
    
    for page in device.pages:
        for widget in page.widgets:
            wtype = (widget.type or "").lower()
            props = widget.props or {}
            
            if wtype == "icon":
                code = (props.get("code") or "").strip()
                size = int(props.get("size", 48) or 48)
                if code and size in fonts_used['icon_fonts_by_size']:
                    if size not in icon_glyphs_by_size:
                        icon_glyphs_by_size[size] = set()
                    icon_glyphs_by_size[size].add(code)
            
            elif wtype == "battery_icon":
                size = int(props.get("size", 48) or 48)
                if size in fonts_used['icon_fonts_by_size']:
                    if size not in icon_glyphs_by_size:
                        icon_glyphs_by_size[size] = set()
                    for code in ["F0079", "F007A", "F007B", "F007C", "F007D", "F007E", "F007F", "F0080", "F0081", "F0082"]:
                        icon_glyphs_by_size[size].add(code)
            
            elif wtype == "weather_icon":
                size = int(props.get("size", 48) or 48)
                if size in fonts_used['icon_fonts_by_size']:
                    if size not in icon_glyphs_by_size:
                        icon_glyphs_by_size[size] = set()
                    for code in ["F0591", "F0594", "F0595", "F192C", "F0E6E", "F0598", "F067F", "F0599", "F06A1", "F0596", "F0590", "F0F32", "F0597", "F0F2F", "F0024"]:
                        icon_glyphs_by_size[size].add(code)
    
    font_lines = []
    
    # Always generate the standard fonts
    font_lines.extend([
        "font:",
        "  # --- Standard Fonts (Auto-Generated) ---",
        "  - file:",
        "      type: gfonts",
        "      family: Roboto",
        "      weight: 700",
        "    id: font_large",
        "    size: 48",
        "    bpp: 1",
        "  - file:",
        "      type: gfonts",
        "      family: Roboto",
        "      weight: 400",
        "    id: font_medium",
        "    size: 24",
        "    bpp: 1",
        "  - file:",
        "      type: gfonts",
        "      family: Roboto",
        "      weight: 400",
        "    id: font_small",
        "    size: 14",
        "    bpp: 1",
        "  - file:",
        "      type: gfonts",
        "      family: Roboto",
        "      weight: 400",
        "    id: font_roboto_400_12",
        "    size: 12",
        "    bpp: 1"
    ])
    
    # Generate custom text fonts that were actually used
    if fonts_used['text_fonts']:
        font_lines.append("")
        font_lines.append("  # Custom text fonts for widget sizes/weights")
        for (family, weight, size), usage in sorted(fonts_used['text_fonts'].items()):
            family_id = family.lower().replace(" ", "_")
            font_id = f"font_{family_id}_{weight}_{size}"
            
            font_lines.extend([
                "  - file:",
                "      type: gfonts",
                f"      family: {family}",
                f"      weight: {weight}",
                f"    id: {font_id}",
                f"    size: {size}",
                "    bpp: 1"
            ])
            
            # Smart Optimization: If not dynamic and we have known chars, restrict glyphs
            if not usage['dynamic'] and usage['chars']:
                chars_str = "".join(sorted(usage['chars'])).replace('"', '\\"')
                font_lines.append(f'    glyphs: "{chars_str}"')
    
    # Generate MDI fonts for icon sizes that were used
    if icon_glyphs_by_size:
        font_lines.append("")
        font_lines.append("  # Material Design Icons (Optimized - Only used glyphs)")
        for size in sorted(icon_glyphs_by_size.keys()):
            glyphs = icon_glyphs_by_size[size]
            unicode_chars = []
            for code in sorted(glyphs):
                try:
                    hex_val = int(code[1:], 16) if code.startswith("F") else int(code, 16)
                    codepoint = 0xF0000 + hex_val
                    unicode_chars.append(chr(codepoint))
                except (ValueError, OverflowError):
                    pass
            
            if unicode_chars:
                glyphs_str = '", "'.join(unicode_chars)
                font_lines.extend([
                    "  - file: fonts/materialdesignicons-webfont.ttf",
                    f"    id: font_mdi_{size}",
                    f"    size: {size}",
                    f'    glyphs: ["{glyphs_str}"]'
                ])
    
    return "\n".join(font_lines)


def _generate_fonts(device: DeviceConfig) -> str:
    """
    Generate font definitions including Material Design Icons fonts for icon widgets.
    Collects all icon codes from the device and generates appropriate MDI fonts.
    Also generates image definitions for image widgets.
    Supports font family selection - uses the first font_family found in widgets, defaults to Inter.
    """
    # Collect icon codes per size to avoid generating huge fonts with unused glyphs
    icon_usage_by_size = {}  # size (int) -> set of codes (str)
    
    # Collect all unique image paths from image widgets and icon sizes
    image_paths = {}
    
    # Track text font usage: (family, weight, size) -> {'dynamic': bool, 'chars': set()}
    text_usage = {}
    selected_font_family = "Inter"  # Default font family
    
    def get_text_usage(family, weight, size):
        key = (family, weight, size)
        if key not in text_usage:
            text_usage[key] = {'dynamic': False, 'chars': set()}
        return text_usage[key]

    for page in device.pages:
        for widget in page.widgets:
            wtype = (widget.type or "").lower()
            if wtype == "icon":
                props = widget.props or {}
                code = (props.get("code") or "").strip()
                size = int(props.get("size", 48) or 48)
                
                if code:
                    if size not in icon_usage_by_size:
                        icon_usage_by_size[size] = set()
                    icon_usage_by_size[size].add(code)

            elif wtype == "battery_icon":
                # Battery icons need all battery level glyphs
                props = widget.props or {}
                size = int(props.get("size", 48) or 48)
                
                if size not in icon_usage_by_size:
                    icon_usage_by_size[size] = set()
                
                # Add all battery icon codes
                for code in ["F0079", "F007A", "F007B", "F007C", "F007D", "F007E", "F007F", "F0080", "F0081", "F0082"]:
                    icon_usage_by_size[size].add(code)

            elif wtype == "weather_icon":
                # Weather icons need all weather state glyphs
                props = widget.props or {}
                size = int(props.get("size", 48) or 48)
                
                if size not in icon_usage_by_size:
                    icon_usage_by_size[size] = set()
                    
                # Add all weather icon codes
                for code in ["F0591", "F0594", "F0595", "F192C", "F0E6E", "F0598", "F067F", "F0599", "F06A1", "F0596", "F0590", "F0F32", "F0597", "F0F2F", "F0024"]:
                    icon_usage_by_size[size].add(code)

            elif wtype in ("text", "label", "sensor_text"):
                props = widget.props or {}
                # Get font family (default Roboto)
                family = props.get("font_family", "Roboto")
                
                # Get weight (default 400)
                weight = int(props.get("font_weight", 400) or 400)
                
                # Collect text font size if specified
                if wtype in ("text", "label"):
                    size = int(props.get("font_size", 20) or 20)
                    usage = get_text_usage(family, weight, size)
                    
                    # Add characters from static text
                    text = (props.get("text") or widget.title or "")
                    for char in text:
                        usage['chars'].add(char)
                        
                else:  # sensor_text
                    label_size = int(props.get("label_font_size", 14) or 14)
                    value_size = int(props.get("value_font_size", 20) or 20)
                    weight_for_value = int(props.get("font_weight", 400) or 400)
                    weight_for_label = 400  # Labels typically use regular weight
                    
                    # Sensor text is dynamic
                    get_text_usage(family, weight_for_label, label_size)['dynamic'] = True
                    get_text_usage(family, weight_for_value, value_size)['dynamic'] = True

            elif wtype == "datetime":
                props = widget.props or {}
                family = props.get("font_family", "Roboto")
                # Datetime usually uses standard weights, but we can support custom if needed
                time_size = int(props.get("time_font_size", 28) or 28)
                date_size = int(props.get("date_font_size", 16) or 16)
                
                # Datetime is dynamic
                get_text_usage(family, 700, time_size)['dynamic'] = True
                get_text_usage(family, 400, date_size)['dynamic'] = True

            elif wtype == "image":
                props = widget.props or {}
                path = (props.get("path") or "").strip()
                if path:
                    # Replicate clamping logic to match _append_widget_render
                    x = max(0, min(widget.x, IMAGE_WIDTH))
                    y = max(0, min(widget.y, IMAGE_HEIGHT))
                    width = max(1, min(widget.width, IMAGE_WIDTH - x))
                    height = max(1, min(widget.height, IMAGE_HEIGHT - y))

                    # Generate safe ID from path
                    safe_path = path.replace("/", "_").replace(".", "_").replace("-", "_").replace(" ", "_")
                    safe_id = f"img_{safe_path}_{width}x{height}"
                    
                    # Collect properties
                    img_type = props.get("image_type", "BINARY").upper()
                    dither = props.get("dither", "FLOYDSTEINBERG").upper()
                    transparency = props.get("transparency", "").lower()
                    
                    image_paths[(path, width, height)] = {
                        "id": safe_id,
                        "type": img_type,
                        "dither": dither,
                        "transparency": transparency
                    }
    
    
    # Always generate the standard fonts that were previously in the hardware template
    # This ensures they are available even if no widgets use them (e.g. for system messages)
    font_lines = []
    
    # Standard Roboto Fonts (replacing the static ones from hardware template)
    font_lines.extend([
        "  # --- Standard Fonts (Auto-Generated) ---",
        "  - file:",
        "      type: gfonts",
        "      family: Roboto",
        "      weight: 700",
        "    id: font_large",
        "    size: 48",
        "    bpp: 1",
        "  - file:",
        "      type: gfonts",
        "      family: Roboto",
        "      weight: 400",
        "    id: font_medium",
        "    size: 24",
        "    bpp: 1",
        "  - file:",
        "      type: gfonts",
        "      family: Roboto",
        "      weight: 400",
        "    id: font_small",
        "    size: 14",
        "    bpp: 1",
        "  - file:",
        "      type: gfonts",
        "      family: Roboto",
        "      weight: 400",
        "    id: font_roboto_400_12",
        "    size: 12",
        "    bpp: 1"
    ])

    # Generate custom text fonts for specific sizes/weights used by widgets
    if text_usage:
        font_lines.append("")
        font_lines.append("  # Custom text fonts for widget sizes/weights")
        for (family, weight, size), usage in sorted(text_usage.items()):
            # Create consistent ID format
            family_id = family.lower().replace(" ", "_")
            font_id = f"font_{family_id}_{weight}_{size}"
            
            font_lines.extend([
                "  - file:",
                "      type: gfonts",
                f"      family: {family}",
                f"      weight: {weight}",
                f"    id: {font_id}",
                f"    size: {size}",
                "    bpp: 1"
            ])
            
            # Smart Optimization: If not dynamic and we have known chars, restrict glyphs
            if not usage['dynamic'] and usage['chars']:
                # Escape chars for YAML string
                chars_str = "".join(sorted(usage['chars'])).replace('"', '\\"')
                font_lines.append(f'    glyphs: "{chars_str}"')
    
    # Add MDI fonts if there are icon widgets
    if icon_usage_by_size:
        font_lines.append("")
        font_lines.append("  # Material Design Icons (Optimized - Only used glyphs)")
        
        # Generate a font for each unique size with ONLY the glyphs needed for that size
        for size, codes in sorted(icon_usage_by_size.items()):
            # Always use size-specific ID for consistency
            font_id = f"font_mdi_{size}"
            
            # Convert codes to Unicode escapes
            glyphs = []
            for code in sorted(codes):
                # code is like "F0595" - convert to actual Unicode character U+F0595
                # Use f-string with \U to create the Unicode character directly
                try:
                    glyphs.append(f'"{chr(0xF0000 + int(code[1:], 16))}"')
                except (ValueError, IndexError):
                    pass
            
            glyph_list = ", ".join(glyphs)
            
            font_lines.extend([
                "  - file: fonts/materialdesignicons-webfont.ttf",
                f"    id: {font_id}",
                f"    size: {size}",
                f"    glyphs: [{glyph_list}]"
            ])
    
    # Add font: parent key
    result = "font:" + "\n" + "\n".join(font_lines)
    
    # Add image definitions if there are image widgets
    if image_paths:
        result += "\n\n\nimage:"
        for (path, width, height), img_data in sorted(image_paths.items()):
            img_id = img_data["id"]
            img_type = img_data.get("type", "BINARY")
            dither = img_data.get("dither", "FLOYDSTEINBERG")
            transparency = img_data.get("transparency", "")
            
            result += f"\n  - file: \"{path}\""
            result += f"\n    id: {img_id}"
            result += f"\n    resize: {width}x{height}"
            result += f"\n    type: {img_type}"
            
            # Dither only applies to BINARY and GRAYSCALE
            if img_type in ("BINARY", "GRAYSCALE"):
                result += f"\n    dither: {dither}"
            
            # Transparency
            if transparency:
                result += f"\n    transparency: {transparency}"
    
    return result


# Removed _generate_outputs_and_buzzer() - now in hardware template


def _generate_text_sensors(device: DeviceConfig, text_entity_ids: set[str], numeric_entity_ids: dict[str, int], local_entity_ids: set[str]) -> str:
    """
    Generate text_sensor and sensor blocks for HomeAssistant entities.
    - text_sensor: for sensor_text widgets (string values)
    - sensor: for progress_bar, battery_icon, graph, and sensor_text with precision (numeric values)
    
    NOTE: To avoid "Duplicate key" errors, we output these as commented instructions
    or a list of items that the user must paste into their existing config.
    
    Local entities are skipped entirely as they are defined in the base ESPHome config.
    """
            
    sections = []
    
    # Generate text_sensor section for text-based widgets
    if text_entity_ids:
        sections.append("text_sensor:")
        for entity_id in sorted(text_entity_ids):
            # Skip local sensors - they are defined in base config
            if entity_id in local_entity_ids:
                continue
            # Skip local IDs (no dot) - assume they are defined elsewhere
            if "." not in entity_id:
                continue
            safe_id = entity_id.replace(".", "_").replace("-", "_")
            sections.append(f"""  - platform: homeassistant
    id: {safe_id}
    entity_id: {entity_id}
    internal: true""")
        sections.append("")
    
    # Generate sensor section for numeric widgets
    if numeric_entity_ids:
        sections.append("# ============================================================================")
        sections.append("# INSTRUCTION: Copy these sensors into your existing 'sensor:' section")
        sections.append("# ============================================================================")
        sections.append("# sensor:")
        for entity_id in sorted(numeric_entity_ids.keys()):
            # Skip local sensors - they are defined in base config
            if entity_id in local_entity_ids:
                continue
            # Skip local IDs (no dot)
            if "." not in entity_id:
                continue
            safe_id = entity_id.replace(".", "_").replace("-", "_")
            precision = numeric_entity_ids[entity_id]
            
            sections.append(f"#   - platform: homeassistant")
            sections.append(f"#     id: {safe_id}")
            sections.append(f"#     entity_id: {entity_id}")
            sections.append(f"#     internal: true")
            if precision >= 0:
                sections.append(f"#     accuracy_decimals: {precision}")
        sections.append("")
    
    if not sections:
        return "# No widgets with entities configured"
    
    return "\n".join(sections) + "\n"


def _classify_entities(device: DeviceConfig) -> tuple[set[str], dict[str, int], set[str]]:
    """
    Scan all widgets to determine which entities are text-based and which are numeric.
    Returns:
        text_entity_ids: Set of entity IDs to be treated as text_sensor
        numeric_entity_ids: Dict of entity IDs to be treated as sensor (value is precision)
        local_entity_ids: Set of entity IDs that are local/on-device (should not be generated)
    """
    text_entity_ids = set()
    numeric_entity_ids = {}  # Map entity_id -> max precision found (-1 = default)
    local_entity_ids = set()  # Track local sensors
    
    # Sensors already defined in the hardware template - do not generate these!
    TEMPLATE_SENSOR_IDS = {
        "battery_voltage",
        "battery_level",
        "wifi_signal_db",
        "sensor_reterminal_e1001_reterminal_onboard_temperature",
        "sensor_reterminal_e1001_reterminal_onboard_humidity"
    }
    
    for page in device.pages:
        for widget in page.widgets:
            entity_id = (widget.entity_id or "").strip()
            if not entity_id:
                continue
            
            wtype = (widget.type or "").lower()
            props = widget.props or {}
            
            # Check both 'is_local_sensor' and 'local' for compatibility
            is_local = props.get("is_local_sensor") or props.get("local")
            if is_local:
                local_entity_ids.add(entity_id)
            
            # Skip if this is a known template sensor
            if entity_id in TEMPLATE_SENSOR_IDS:
                continue
            
            # Widgets that need numeric (float) values
            if wtype in ("progress_bar", "battery_icon", "graph"):
                if entity_id not in numeric_entity_ids:
                    numeric_entity_ids[entity_id] = -1
            # Weather icon needs text state
            elif wtype == "weather_icon":
                if entity_id not in numeric_entity_ids:
                    text_entity_ids.add(entity_id)
            # sensor_text can be numeric if precision is specified
            elif wtype == "sensor_text":
                precision = int(props.get("precision", -1))
                
                # Local sensors are ALWAYS numeric
                if is_local:
                    current = numeric_entity_ids.get(entity_id, -2)
                    numeric_entity_ids[entity_id] = max(current, precision)
                # Has precision specified - treat as numeric
                elif precision >= 0:
                    current = numeric_entity_ids.get(entity_id, -2)
                    numeric_entity_ids[entity_id] = max(current, precision)
                # Default to text for HA entities without precision
                else:
                    if entity_id not in numeric_entity_ids:
                        text_entity_ids.add(entity_id)
            # Other widgets
            else:
                if entity_id not in numeric_entity_ids:
                    text_entity_ids.add(entity_id)
    
    # Remove entities from text_set if they are in numeric_set (numeric takes precedence)
    for eid in list(text_entity_ids):
        if eid in numeric_entity_ids:
            text_entity_ids.remove(eid)
            
    return text_entity_ids, numeric_entity_ids, local_entity_ids





def _generate_scripts(device: DeviceConfig) -> str:
    """
    Generate time + manage_run_and_sleep script with per-page refresh support.
    Includes night-time power saving logic if enabled.

    Semantics:
    - A global default interval (page_refresh_default_s).
    - Inline switch(page) using PageConfig.refresh_s values when provided.
    - Enforce a minimum of 60 seconds for any effective interval.
    - Night mode: Deep sleep between start_hour and end_hour, waking only at top of hour.
    """
    if device.manual_refresh_only:
        return """script:
  - id: manage_run_and_sleep
    mode: restart
    then:
      - logger.log: "Manual refresh only mode. Auto-refresh loop disabled."
"""

    case_lines: List[str] = []
    for idx, page in enumerate(device.pages):
        refresh = getattr(page, "refresh_s", None)
        if refresh is None:
            continue
        try:
            val = int(refresh)
        except (TypeError, ValueError):
            continue
        if val >= 60:
            case_lines.append(f"                  case {idx}: interval = {val}; break;")

    if case_lines:
        cases_block = "\n".join(case_lines)
    else:
        cases_block = "                  default:\n                    break;"

    # Sleep logic
    sleep_logic = ""
    if getattr(device, "sleep_enabled", False):
        start_h = int(getattr(device, "sleep_start_hour", 0))
        end_h = int(getattr(device, "sleep_end_hour", 5))
        
        # Handle wrap-around time (e.g. 22:00 to 06:00)
        if start_h > end_h:
            condition = f"(now.hour >= {start_h} || now.hour < {end_h})"
        else:
            condition = f"(now.hour >= {start_h} && now.hour < {end_h})"
            
        sleep_logic = f"""
      # Night Mode Check ({start_h:02d}:00 - {end_h:02d}:00)
      - if:
          condition:
            lambda: |-
              auto now = id(ha_time).now();
              if (!now.is_valid()) {{
                return false;
              }}
              // Deep sleep only between {start_h:02d}:00 and {end_h:02d}:00
              // But skip if it's exactly the top of the hour (we just woke up to refresh)
              return {condition} && !(now.minute == 0);
          then:
            - lambda: |-
                auto now = id(ha_time).now();
                if (now.is_valid()) {{
                  ESP_LOGI("sleep", "Deep sleep mode %02d:%02d", now.hour, now.minute);
                }}
            - if:
                condition:
                  lambda: |-
                    auto now = id(ha_time).now();
                    return now.is_valid() && (now.minute == 0);
                then:
                  - component.update: epaper_display
                else:
                  - logger.log: "Deep sleep mode: skipping refresh until the top of the hour."
            - deep_sleep.enter:
                id: deep_sleep_1
                sleep_duration: 60min
          
          # Active Mode
          else:"""
    else:
        # No sleep logic, just fall through to active mode
        sleep_logic = """
      # Sleep mode disabled
      - if:
          condition:
            lambda: 'return false;'
          then:
            - delay: 1s
          else:"""

    # No Refresh Logic
    no_refresh_logic = ""
    nr_start = getattr(device, "no_refresh_start_hour", None)
    nr_end = getattr(device, "no_refresh_end_hour", None)
    
    if nr_start is not None and nr_end is not None:
        try:
            s_h = int(nr_start)
            e_h = int(nr_end)
            if s_h > e_h:
                cond = f"(now.hour >= {s_h} || now.hour < {e_h})"
            else:
                cond = f"(now.hour >= {s_h} && now.hour < {e_h})"
            
            no_refresh_logic = f"""
            - if:
                condition:
                  lambda: |-
                    auto now = id(ha_time).now();
                    return now.is_valid() && {cond};
                then:
                  - logger.log: "In no-refresh window. Skipping display update."
                  - delay: 60s
                  - script.execute: manage_run_and_sleep
                  - script.stop: manage_run_and_sleep
            """
        except (ValueError, TypeError):
            pass

    # Build image trigger logic to prevent race conditions
    # If page has online images, trigger them and let them update display.
    # Otherwise, update display directly.
    image_cases = []
    for idx, page in enumerate(device.pages):
        page_images = []
        for w in page.widgets:
            wtype = (w.type or "").lower()
            if wtype == "online_image":
                safe_id = f"online_image_{w.id}".replace("-", "_")
                page_images.append(safe_id)
            elif wtype == "puppet":
                safe_id = f"puppet_{w.id}".replace("-", "_")
                page_images.append(safe_id)
        
        if page_images:
            updates = " ".join([f"id({pid}).update();" for pid in page_images])
            image_cases.append(f"                  case {idx}: {updates} triggered = true; break;")

    if image_cases:
        image_cases_block = "\n".join(image_cases)
        update_lambda = f"""            - lambda: |-
                bool triggered = false;
                int page = id(display_page);
                switch (page) {{
{image_cases_block}
                }}
                if (!triggered) {{
                  id(epaper_display).update();
                }}"""
    else:
        update_lambda = "            - component.update: epaper_display"

    return """script:
  - id: manage_run_and_sleep
    mode: restart
    then:
      - wait_until:
          condition:
            lambda: 'return id(ha_time).now().is_valid();'
          timeout: 120s
      {sleep_logic}
            - lambda: |-
                int page = id(display_page);
                int interval = id(page_refresh_default_s);
                switch (page) {{
{cases_block}
                }}
                if (interval < 60) {{
                  interval = 60;
                }}
                id(page_refresh_current_s) = interval;
                ESP_LOGI("refresh", "Next refresh in %d seconds for page %d", interval, page);
            
            {no_refresh_logic}
{update_lambda}
            - delay: !lambda 'return id(page_refresh_current_s) * 1000;'
            - script.execute: manage_run_and_sleep
""".format(sleep_logic=sleep_logic, cases_block=cases_block, no_refresh_logic=no_refresh_logic, update_lambda=update_lambda)


def _generate_graphs(device: DeviceConfig) -> str:
    """
    Generate graph definitions for graph widgets.
    """
    graph_widgets = []
    for page in device.pages:
        for widget in page.widgets:
            if (widget.type or "").lower() == "graph":
                graph_widgets.append(widget)
    
    if not graph_widgets:
        return "# No graph widgets configured"
        
    lines = ["graph:"]
    for widget in graph_widgets:
        props = widget.props or {}
        entity_id = (widget.entity_id or "").strip()
        if not entity_id:
            continue
            
        # Generate safe ID
        safe_id = f"graph_{widget.id}".replace("-", "_")
        
        lines.append(f"  - id: {safe_id}")
        lines.append(f"    duration: {props.get('duration', '1h')}")
        # Calculate clamped dimensions to ensure graph stays within bounds
        # This matches the logic in _append_widget_render
        x = max(0, min(widget.x, IMAGE_WIDTH))
        y = max(0, min(widget.y, IMAGE_HEIGHT))
        w = max(1, min(widget.width, IMAGE_WIDTH - x))
        h = max(1, min(widget.height, IMAGE_HEIGHT - y))

        lines.append(f"    width: {w}")
        lines.append(f"    height: {h}")
        
        # Optional border (default true in ESPHome, but we allow control)
        if "border" in props:
            lines.append(f"    border: {str(props['border']).lower()}")

        # Optional grid settings
        if props.get("x_grid"):
            lines.append(f"    x_grid: {props['x_grid']}")
        if props.get("y_grid"):
            lines.append(f"    y_grid: {props['y_grid']}")

        # Y-axis range settings
        if props.get("max_range"):
            lines.append(f"    max_range: {props['max_range']}")
        if props.get("min_range"):
            lines.append(f"    min_range: {props['min_range']}")
        if props.get("max_value"):
            lines.append(f"    max_value: {props['max_value']}")
        if props.get("min_value"):
            lines.append(f"    min_value: {props['min_value']}")
            
        # Traces (currently only one supported by editor UI)
        lines.append("    traces:")
        # Sanitize sensor ID for the trace
        safe_sensor_id = entity_id.replace(".", "_").replace("-", "_")
        lines.append(f"      - sensor: {safe_sensor_id}")
        
        # Trace styling
        if props.get("line_type"):
            lines.append(f"        line_type: {props['line_type']}")
        if props.get("line_thickness"):
            lines.append(f"        line_thickness: {props['line_thickness']}")
        if props.get("color"):
            # Map color name to ID if possible, or use raw value if it's a defined color id
            # For now, assuming standard colors or user-defined IDs
            color_val = props['color']
            if color_val in ["black", "white"]:
                 # ESPHome graph colors usually refer to a color ID defined in color: section
                 # We might need to define these if they don't exist, or use a default.
                 # For e-paper, it's usually just black/white.
                 pass 
            else:
                 lines.append(f"        color: {color_val}")
        if props.get("continuous"):
            lines.append(f"        continuous: true")

    return "\n".join(lines)


def _generate_display_block_and_track_fonts(device: DeviceConfig, numeric_entity_ids: dict[str, int]) -> tuple[str, dict]:
    """
    Generate the display: epaper_display block while tracking all fonts that are referenced.
    Returns: (display_block_yaml, fonts_used)
    
    fonts_used format: {
        'text_fonts': {(family, weight, size): {'dynamic': bool, 'chars': set()}},
        'icon_fonts_by_size': {size: set_of_glyph_codes}
    }
    """
    fonts_used = {
        'text_fonts': {},
        'icon_fonts_by_size': {}
    }
    
    lines: List[str] = []

    orientation = getattr(device, "orientation", "landscape")
    if orientation == "portrait":
        rotation = 90
    else:
        rotation = 0

    lines.append("display:")
    lines.append("  - platform: waveshare_epaper")
    lines.append("    id: epaper_display")
    lines.append("    model: ${display_model}")
    lines.append("    cs_pin: ${display_cs_pin}")
    lines.append("    dc_pin: ${display_dc_pin}")
    lines.append("    reset_pin:")
    lines.append("      number: ${display_reset_pin}")
    lines.append("      inverted: false")
    lines.append("    busy_pin:")
    lines.append("      number: ${display_busy_pin}")
    lines.append("      inverted: true")
    lines.append("    update_interval: never")
    lines.append("    lambda: |-")
    lines.append("      // Define common colors for widgets")
    lines.append("      Color COLOR_ON = Color(1);")
    lines.append("      Color COLOR_OFF = Color(0);")
    lines.append("      it.fill(COLOR_OFF);")
    lines.append("")

    for page_index, page in enumerate(device.pages):
        _append_page_render(lines, page_index, page, numeric_entity_ids, fonts_used)

    return "\n".join(lines), fonts_used


def _generate_display_block(device: DeviceConfig, numeric_entity_ids: dict[str, int]) -> str:
    """
    Generate the display: epaper_display block with a lambda that:
    - Reads current display_page.
    - Draws widgets belonging to the active page.
    - Uses DeviceConfig.orientation to pick rotation:
        - landscape -> rotation: 0
        - portrait  -> rotation: 90
    - DeviceConfig.dark_mode is advisory; widget-level color/invert decide actual draws.
    """
    lines: List[str] = []

    orientation = getattr(device, "orientation", "landscape")
    if orientation == "portrait":
        rotation = 90
    else:
        rotation = 0

    lines.append("display:")
    lines.append("  - platform: waveshare_epaper")
    lines.append("    id: epaper_display")
    lines.append("    model: ${display_model}")
    lines.append("    cs_pin: ${display_cs_pin}")
    lines.append("    dc_pin: ${display_dc_pin}")
    lines.append("    reset_pin:")
    lines.append("      number: ${display_reset_pin}")
    lines.append("      inverted: false")
    lines.append("    busy_pin:")
    lines.append("      number: ${display_busy_pin}")
    lines.append("      inverted: true")
    lines.append("    update_interval: never")
    lines.append("    lambda: |-")
    lines.append("      // Define common colors for widgets")
    lines.append("      Color COLOR_ON = Color(1);")
    lines.append("      Color COLOR_OFF = Color(0);")
    lines.append("      it.fill(COLOR_OFF);")
    lines.append("")

    for page_index, page in enumerate(device.pages):
        _append_page_render(lines, page_index, page, numeric_entity_ids)

    return "\n".join(lines)


def _generate_online_images(device: DeviceConfig) -> str:
    """
    Generate `online_image:` blocks for widgets of type `online_image`.
    Each widget becomes an `online_image` entry with an id derived from the widget id.
    """
    image_widgets = []
    for pidx, page in enumerate(device.pages):
        for widget in page.widgets:
            wtype = (widget.type or "").lower()
            if wtype == "online_image" or wtype == "puppet":
                image_widgets.append((pidx, widget))

    if not image_widgets:
        return "# No online_image widgets configured"

    lines: List[str] = [
        "# Remote/puppet images (online_image)",
        "# NOTE: Requires http_request: component (already in hardware template)",
        "",
        "online_image:"  # Single parent key for all images
    ]
    
    for pidx, widget in image_widgets:
        props = widget.props or {}
        url = (props.get("url") or props.get("image_url") or "").strip()
        wtype = (widget.type or "").lower()
        
        # Safe id for ESPHome matching frontend logic
        if wtype == "puppet":
            safe_id = f"puppet_{widget.id}".replace("-", "_")
        else:
            safe_id = f"online_image_{widget.id}".replace("-", "_")

        # Default properties
        img_format = (props.get("format", "PNG") or "PNG").upper()  # PNG or JPEG
        # ESPHome expects "JPEG" not "JPG"
        if img_format == "JPG":
            img_format = "JPEG"
        img_type = (props.get("type", "GRAYSCALE") or "GRAYSCALE").upper()  # GRAYSCALE for e-paper
        resize = f"{widget.width}x{widget.height}"
        update_interval = props.get("update_interval", "1h")

        lines.append(f"  - id: {safe_id}")
        if url:
            lines.append(f"    url: \"{url}\"")
        lines.append(f"    format: {img_format}")
        lines.append(f"    type: {img_type}")
        lines.append(f"    resize: {resize}")
        lines.append(f"    update_interval: never")
        # on_download_finished: update epaper_display when this page is visible
        lines.append("    on_download_finished:")
        lines.append("      then:")
        lines.append(f"        - component.update: epaper_display")
        lines.append("    on_error:")
        lines.append("      then:")
        lines.append(f"        - component.update: epaper_display")

    return "\n".join(lines)


def _append_page_render(dst: List[str], page_index: int, page: PageConfig, numeric_entity_ids: dict[str, int]) -> None:
    indent = "      "
    dst.append(f'{indent}if (id(display_page) == {page_index}) {{')
    if not page.widgets:
        dst.append(f"{indent}  // Page {page_index}: no widgets configured.")
    else:
        for widget in page.widgets:
            _append_widget_render(dst, indent + "  ", widget, numeric_entity_ids)
    dst.append(f"{indent}}}")


def _resolve_font(props: dict, default_weight: int = 400) -> str:
    """Pick a font id based on font_family, font_size and font_weight in widget props."""
    try:
        size = int(props.get("font_size", 20))
    except (TypeError, ValueError):
        size = 20
        
    try:
        weight = int(props.get("font_weight", default_weight))
    except (TypeError, ValueError):
        weight = default_weight

    # Get font family, default to Roboto
    family = props.get("font_family", "Roboto")
    
    # Convert to template format: font_<family>_<weight>_<size>
    # e.g., "Open Sans" -> "open_sans"
    family_id = family.lower().replace(" ", "_")
    
    return f"id(font_{family_id}_{weight}_{size})"


def _resolve_font_by_size(size: int, weight: int = 400, family: str = "Roboto") -> str:
    """Pick a font id based on explicit font size, weight, and family."""
    if size <= 0:
        size = 20
    
    # Convert to template format: font_<family>_<weight>_<size>
    # e.g., "Open Sans" -> "open_sans"
    family_id = family.lower().replace(" ", "_")
    
    return f"id(font_{family_id}_{weight}_{size})"


def _wrap_with_condition(dst: List[str], indent: str, widget: WidgetConfig, content_lines: List[str], numeric_entity_ids: dict[str, int]) -> None:
    """Wrap widget rendering code with conditional visibility if configured."""
    
    # Fallback to widget.entity_id if condition_entity is not set
    cond_entity = widget.condition_entity or widget.entity_id

    # Check for Single Value mode
    has_single = (
        cond_entity and 
        widget.condition_state is not None and 
        widget.condition_operator
    )
    
    # Check for Range mode
    has_range = (
        cond_entity and 
        (widget.condition_min is not None or widget.condition_max is not None)
    )
    
    if not has_single and not has_range:
        # No condition - just append content
        dst.extend(content_lines)
        return
    
    # Generate safe ID from entity_id for condition
    if "." in cond_entity:
        safe_cond_id = cond_entity.replace(".", "_").replace("-", "_")
    else:
        safe_cond_id = cond_entity
    
    # Determine if condition entity is numeric
    is_numeric = cond_entity in numeric_entity_ids
    
    dst.append(f'{indent}{{')
    
    # Prepare value access
    if is_numeric:
        val_expr = f"id({safe_cond_id}).state"
    else:
        # For text sensors, we need to parse float for range or numeric ops
        dst.append(f'{indent}  float cond_val = atof(id({safe_cond_id}).state.c_str());')
        val_expr = "cond_val"

    if has_range:
        # Range Logic (Min/Max)
        # Default to AND (Inside) if not specified
        logic = (widget.condition_logic or "and").lower()
        
        parts = []
        if widget.condition_min is not None:
            parts.append(f"{val_expr} > {widget.condition_min}")
        if widget.condition_max is not None:
            parts.append(f"{val_expr} < {widget.condition_max}")
            
        if parts:
            join_op = " && " if logic == "and" else " || "
            condition = join_op.join(parts)
            dst.append(f'{indent}  if ({condition}) {{')
        else:
            # Should not happen if has_range is true, but fallback
            dst.append(f'{indent}  if (true) {{')
            
    else:
        # Single Value Logic
        cond_state = str(widget.condition_state).replace('"', '\\"')
        cond_op = widget.condition_operator or "=="
        
        if cond_op in (">", "<", ">=", "<="):
            # Numeric comparison
            if is_numeric:
                dst.append(f'{indent}  if ({val_expr} {cond_op} {cond_state}) {{')
            else:
                # Text sensor uses parsed float
                dst.append(f'{indent}  if ({val_expr} {cond_op} {cond_state}) {{')
        else:
            # Equality/Inequality
            if is_numeric:
                # Direct float comparison
                dst.append(f'{indent}  if ({val_expr} {cond_op} {cond_state}) {{')
            else:
                # String comparison for text sensors
                if cond_op == "==":
                    dst.append(f'{indent}  if (id({safe_cond_id}).state == "{cond_state}") {{')
                else:
                    dst.append(f'{indent}  if (id({safe_cond_id}).state != "{cond_state}") {{')

    # Content needs extra indent
    indented_content = [line.replace(indent, indent + "    ", 1) if line.startswith(indent) else "    " + line for line in content_lines]
    dst.extend(indented_content)
    
    dst.append(f'{indent}  }}')
    dst.append(f'{indent}}}')


def _append_widget_render(dst: List[str], indent: str, widget: WidgetConfig, numeric_entity_ids: dict[str, int]) -> None:
    """Render a single widget into display lambda C++ code.

    Unified styling semantics:
    - type: "text" / "label"
    - type: "sensor" / "sensor_text"
    - type: "datetime"
    - type: "progress_bar"
    - type: "battery_icon"
    - type: "shape_rect"
    - type: "shape_circle"
    - type: "line"
    - type: "image"
    - type: "history"
    
    Supports conditional visibility based on entity state.
    """
    # ============================================================================
    # CRITICAL: Widget coordinate clamping
    # DO NOT CHANGE: Clamps widget positions to canvas bounds (800x480)
    # These clamped values are written to YAML markers and must be parsed back exactly
    # ============================================================================
    x = max(0, min(widget.x, IMAGE_WIDTH))
    y = max(0, min(widget.y, IMAGE_HEIGHT))
    w = max(1, min(widget.width, IMAGE_WIDTH - x))
    h = max(1, min(widget.height, IMAGE_HEIGHT - y))
    
    wtype = (widget.type or "text").lower()
    
    _LOGGER.debug(f"Generating widget {widget.id} type={wtype} x={widget.x}{x} y={widget.y}{y} w={widget.width}{w} h={widget.height}{h}")
    props = widget.props or {}

    # Determine base color polarity from props.color and invert.
    base_color = (props.get("color") or "").lower()
    # E-Paper: COLOR_ON = black ink, COLOR_OFF = white (no ink)
    if base_color == "white":
        fg = "COLOR_OFF"  # White = no ink
    elif base_color == "gray":
        # For grayscale we still use black ink; left for future patterns.
        fg = "COLOR_ON"
    else:
        # Default to black ink
        fg = "COLOR_ON"

    if props.get("invert"):
        fg = "COLOR_OFF" if fg == "COLOR_ON" else "COLOR_ON"

    # Collect widget rendering code, then wrap with condition if needed
    content: List[str] = []

    # Floating text (no box)
    if wtype in ("label", "text"):
        text = (props.get("text") or widget.title or "").replace('"', '\\"')
        if not text:
            return
        font = _resolve_font(props)
        font_size = int(props.get("font_size", 12) or 12)
        font_family = props.get("font_family") or "Inter"
        color_prop = (props.get("color") or "black").lower()
        font_style = props.get("font_style") or "regular"
        font_weight = int(props.get("font_weight", 400) or 400)
        text_align = props.get("text_align", "TOP_LEFT").upper()
        
        # Calculate correct x coordinate based on alignment
        if text_align == "TOP_CENTER":
            align_x = x + w // 2
        elif text_align == "TOP_RIGHT":
            align_x = x + w
        else:  # TOP_LEFT
            align_x = x
            
        # Add marker comment for parser with all properties including font_family and font_weight
        content.append(f'{indent}// widget:text id:{widget.id} type:text x:{x} y:{y} w:{w} h:{h} text:"{text}" font_size:{font_size} font_family:"{font_family}" font_weight:{font_weight} weight:{font_weight} color:{color_prop} font_style:{font_style} text_align:{text_align}')
        content.append(f'{indent}it.print({align_x}, {y}, {font}, {fg}, TextAlign::{text_align}, "{text}");')
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Icon widget (MDI icon from font)
    if wtype == "icon":
        code = (props.get("code") or "F0595").strip().upper()
        # Validate code format (Fxxx)
        if not code.startswith("F") or len(code) != 5:
            code = "F0595"  # Default to weather-cloudy
        # Convert to unicode codepoint
        try:
            hex_val = int(code[1:], 16)
            codepoint = 0xF0000 + hex_val
            icon_char = chr(codepoint)
        except (ValueError, OverflowError):
            icon_char = chr(0xF0595)  # Fallback
        
        # Determine font based on size - always use size-specific ID
        size = int(props.get("size", 48) or 48)
        font_id = f"font_mdi_{size}"
        
        # Always use the calculated font_id, ignore any stored font_ref (could be outdated)
        font_ref = font_id
        
        # Handle color property - icon widgets have their own color, don't use base fg
        color_prop = (props.get("color") or "black").lower()
        if color_prop == "white":
            icon_color = "COLOR_OFF"
        elif color_prop == "gray":
            icon_color = "COLOR_ON"  # E-paper doesn't have gray, use black
        else:  # black or default
            icon_color = "COLOR_ON"
        
        # Escape special characters
        escaped_char = icon_char.replace("\\", "\\\\").replace('"', '\\"')
        # Add marker comment for parser
        content.append(f'{indent}// widget:icon id:{widget.id} type:icon x:{x} y:{y} w:{w} h:{h} code:{code} size:{size} color:{color_prop}')
        content.append(f'{indent}it.print({x}, {y}, id({font_ref}), {icon_color}, "{escaped_char}");')
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Sensor text (label + value from HA sensor)
    if wtype in ("sensor", "sensor_text"):
        entity_id = (widget.entity_id or "").strip()
        label = (widget.title or "").replace('"', '\\"')
        value_format = props.get("value_format", "label_value")
        label_font_size = int(props.get("label_font_size", 14) or 14)
        value_font_size = int(props.get("value_font_size", 20) or 20)
        font_family = props.get("font_family") or "Inter"
        font_weight = int(props.get("font_weight", 400) or 400)
        precision = int(props.get("precision", -1))
        
        if entity_id:
            # Generate safe ID from entity_id (handle local vs HA)
            if "." in entity_id:
                safe_id = entity_id.replace(".", "_").replace("-", "_")
            else:
                safe_id = entity_id
            
            # Determine if entity is numeric
            is_numeric = entity_id in numeric_entity_ids
            # Force text mode if explicitly requested
            if props.get("is_text_sensor"):
                is_numeric = False
                
            # Format string and value expression
            unit = props.get("unit", "")
            if is_numeric:
                precision = int(props.get("precision", -1))
                if precision < 0:
                    fmt = "%.1f"
                else:
                    fmt = f"%.{precision}f"
                val_expr = f"id({safe_id}).state"
            else:
                fmt = "%s"
                val_expr = f"id({safe_id}).state.c_str()"
                
            # Add marker comment for parser
            # CRITICAL: Parser depends on exact format
            is_local = "true" if props.get("is_local_sensor") else "false"
            is_text = "true" if not is_numeric else "false"
            
            # Support separate alignments for label and value
            text_align = props.get("text_align", "TOP_LEFT").upper()
            label_align = props.get("label_align", text_align).upper()
            value_align = props.get("value_align", text_align).upper()
            
            # Helper function to calculate x coordinate based on alignment
            def get_align_x(alignment):
                if alignment == "TOP_CENTER":
                    return x + w // 2
                elif alignment == "TOP_RIGHT":
                    return x + w
                else:  # TOP_LEFT
                    return x
            
            label_font = _resolve_font_by_size(label_font_size, font_weight, font_family)
            value_font = _resolve_font_by_size(value_font_size, font_weight, font_family)

            content.append(f'{indent}// widget:sensor_text id:{widget.id} type:sensor_text x:{x} y:{y} w:{w} h:{h} ent:{entity_id} title:"{label}" format:{value_format} label_font:{label_font_size} value_font:{value_font_size} color:{base_color} label_align:{label_align} value_align:{value_align} precision:{props.get("precision", -1)} unit:"{unit}" local:{is_local} text_sensor:{is_text} font_family:"{font_family}" font_weight:{font_weight}')

            if value_format == "label_newline_value" and label:
                # Label on top, value below (using separate alignments and coordinates)
                label_x = get_align_x(label_align)
                value_x = get_align_x(value_align)
                content.append(f'{indent}it.printf({label_x}, {y}, {label_font}, {fg}, TextAlign::{label_align}, "{label}");')
                # Value below label
                content.append(f'{indent}it.printf({value_x}, {y} + {label_font_size} + 2, {value_font}, {fg}, TextAlign::{value_align}, "{fmt}%s", {val_expr}, "{unit}");')
            elif value_format == "label_value" and label:
                # Inline format: "Label: Value" - use value_align since it's a single line
                value_x = get_align_x(value_align)
                content.append(f'{indent}it.printf({value_x}, {y}, {value_font}, {fg}, TextAlign::{value_align}, "{label}: {fmt}%s", {val_expr}, "{unit}");')
            else:
                # value_only or no label - just show value
                font = _resolve_font_by_size(value_font_size, font_weight, font_family)
                value_x = get_align_x(value_align)
                content.append(f'{indent}it.printf({value_x}, {y}, {font}, {fg}, TextAlign::{value_align}, "{fmt}%s", {val_expr}, "{unit}");')
        else:
            # No entity_id configured - show placeholder
            placeholder = label or "sensor"
            font = _resolve_font_by_size(value_font_size, font_weight, font_family)
            # Add marker comment for parser with font sizes and font_family
            content.append(f'{indent}// widget:sensor_text id:{widget.id} type:sensor_text x:{x} y:{y} w:{w} h:{h} title:"{label}" label_font:{label_font_size} value_font:{value_font_size} format:{value_format} font_family:"{font_family}" font_weight:{font_weight} precision:{precision}')
            content.append(f'{indent}// No entity_id configured for this sensor_text widget')
            content.append(f'{indent}it.printf({x}, {y}, {font}, {fg}, "{placeholder}: N/A");')
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Date/time widget
    if wtype == "datetime":
        format_type = props.get("format", "time_date")
        time_font_size = int(props.get("time_font_size", 28) or 28)
        date_font_size = int(props.get("date_font_size", 16) or 16)
        
        # Extract font_family for marker (even though datetime currently doesn't use it for rendering)
        font_family = props.get("font_family") or "Inter"
        
        time_font = _resolve_font_by_size(time_font_size, 700, font_family)
        date_font = _resolve_font_by_size(date_font_size, 400, font_family)
        
        # Calculate center X for alignment
        cx = x + w // 2
        
        # Add marker comment for parser
        content.append(f'{indent}// widget:datetime id:{widget.id} type:datetime x:{x} y:{y} w:{w} h:{h} format:{format_type} time_font:{time_font_size} date_font:{date_font_size} color:{base_color} font_family:"{font_family}"')
        
        if format_type == "time_only":
            # Time only - centered
            content.append(f'{indent}it.strftime({cx}, {y}, {time_font}, {fg}, TextAlign::TOP_CENTER, "%H:%M", id(ha_time).now());')
        elif format_type == "date_only":
            # Date only - centered
            content.append(f'{indent}it.strftime({cx}, {y}, {date_font}, {fg}, TextAlign::TOP_CENTER, "%a, %b %d", id(ha_time).now());')
        else:
            # time_date - time on top, date below
            content.append(f'{indent}it.strftime({cx}, {y}, {time_font}, {fg}, TextAlign::TOP_CENTER, "%H:%M", id(ha_time).now());')
            date_y = y + time_font_size + 4
            content.append(f'{indent}it.strftime({cx}, {date_y}, {date_font}, {fg}, TextAlign::TOP_CENTER, "%a, %b %d", id(ha_time).now());')
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Progress bar widget
    if wtype == "progress_bar":
        entity_id = (widget.entity_id or "").strip()
        label = (widget.title or "").replace('"', '\\"')
        show_label = props.get("show_label", True)
        show_percentage = props.get("show_percentage", True)
        bar_height = int(props.get("bar_height", 15) or 15)
        border_width = int(props.get("border_width", 1) or 1)
        
        show_label_str = "true" if show_label else "false"
        show_pct_str = "true" if show_percentage else "false"
        is_local = "true" if props.get("is_local_sensor") else "false"

        if not entity_id:
            # No entity configured - show placeholder
            # CRITICAL: Must include coordinates even if no entity, otherwise parser defaults to 40,40
            # Also include style properties so they persist
            content.append(f'{indent}// widget:progress_bar id:{widget.id} type:progress_bar x:{x} y:{y} w:{w} h:{h} label:"{label}" bar_height:{bar_height} border:{border_width} show_label:{show_label_str} show_pct:{show_pct_str} color:{base_color} (no entity configured)')
            content.append(f'{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});')
            _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
            return
        
        # Generate safe ID from entity_id (handle local vs HA)
        if "." in entity_id:
            safe_id = entity_id.replace(".", "_").replace("-", "_")
        else:
            safe_id = entity_id
        
        # ============================================================================
        # CRITICAL: Progress bar marker comment format
        # DO NOT CHANGE: Parser depends on exact format: x:{x} y:{y} w:{w} h:{h}
        # These coordinates must be preserved for round-trip editing to work
        # ============================================================================
        content.append(f'{indent}// widget:progress_bar id:{widget.id} type:progress_bar x:{x} y:{y} w:{w} h:{h} ent:{entity_id} title:"{label}" show_label:{show_label_str} show_pct:{show_pct_str} bar_h:{bar_height} border_w:{border_width} color:{base_color} local:{is_local}')
        
        # Calculate vertical layout
        label_y = y
        bar_y = y
        
        if show_label and (label or show_percentage):
            # Label/percentage row at top
            if label and show_percentage:
                # Both label and percentage
                label_font = _resolve_font_by_size(12)
                content.append(f'{indent}it.printf({x}, {label_y}, {label_font}, {fg}, "{label}");')
                # Percentage on the right
                content.append(f'{indent}it.printf({x}+{w}-30, {label_y}, {label_font}, {fg}, "%.0f%%", id({safe_id}).state);')
            elif label:
                # Label only
                label_font = _resolve_font_by_size(12)
                content.append(f'{indent}it.printf({x}, {label_y}, {label_font}, {fg}, "{label}");')
            elif show_percentage:
                # Percentage only
                label_font = _resolve_font_by_size(12)
                content.append(f'{indent}it.printf({x}, {label_y}, {label_font}, {fg}, "%.0f%%", id({safe_id}).state);')
            
            bar_y = label_y + 16
        
        # Draw progress bar border
        content.append(f'{indent}it.rectangle({x}, {bar_y}, {w}, {bar_height}, {fg});')
        
        # Draw progress bar fill (clamp to 0-100%)
        content.append(f'{indent}// Fill progress bar based on sensor value (0-100%)')
        content.append(f'{indent}{{')
        content.append(f'{indent}  float progress = id({safe_id}).state;')
        content.append(f'{indent}  if (progress < 0) progress = 0;')
        content.append(f'{indent}  if (progress > 100) progress = 100;')
        content.append(f'{indent}  int fill_width = (int)(({w} - 2) * (progress / 100.0));')
        content.append(f'{indent}  if (fill_width > 0) {{')
        content.append(f'{indent}    it.filled_rectangle({x}+1, {bar_y}+1, fill_width, {bar_height}-2, {fg});')
        content.append(f'{indent}  }}')
        content.append(f'{indent}}}')
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Battery icon widget - dynamic icon based on battery level
    if wtype == "battery_icon":
        entity_id = (widget.entity_id or "").strip()
        size = int(props.get("size", 48) or 48)
        font_id = f"font_mdi_{size}"
        
        if not entity_id:
            # No entity configured - show static battery icon
            # CRITICAL: Must include coordinates even if no entity, otherwise parser defaults to 40,40
            # Also include size so it persists
            content.append(f'{indent}// widget:battery_icon id:{widget.id} type:battery_icon x:{x} y:{y} w:{w} h:{h} size:{size} color:{base_color} (no entity configured)')
            content.append(f'{indent}it.printf({x}, {y}, id({font_id}), {fg}, "\\U000F0079");  // battery')
            _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
            return
        
        # Generate safe ID from entity_id (handle local vs HA)
        if "." in entity_id:
            safe_id = entity_id.replace(".", "_").replace("-", "_")
        else:
            safe_id = entity_id
        
        # ============================================================================
        # CRITICAL: Battery icon marker comment format
        # DO NOT CHANGE: Parser depends on exact format: x:{x} y:{y} w:{w} h:{h}
        # These coordinates must be preserved for round-trip editing to work
        # ============================================================================
        is_local = "true" if props.get("is_local_sensor") else "false"
        content.append(f'{indent}// widget:battery_icon id:{widget.id} type:battery_icon x:{x} y:{y} w:{w} h:{h} ent:{entity_id} size:{size} color:{base_color} local:{is_local}')
        
        # Add logic to pick battery icon based on level
        content.append(f'{indent}{{')
        content.append(f'{indent}  float level = id({safe_id}).state;')
        content.append(f'{indent}  const char* icon;')
        content.append(f'{indent}  if (level <= 10)      icon = "\\U000F007A";  // battery-10')
        content.append(f'{indent}  else if (level <= 20) icon = "\\U000F007B";  // battery-20')
        content.append(f'{indent}  else if (level <= 30) icon = "\\U000F007C";  // battery-30')
        content.append(f'{indent}  else if (level <= 40) icon = "\\U000F007D";  // battery-40')
        content.append(f'{indent}  else if (level <= 50) icon = "\\U000F007E";  // battery-50')
        content.append(f'{indent}  else if (level <= 60) icon = "\\U000F007F";  // battery-60')
        content.append(f'{indent}  else if (level <= 70) icon = "\\U000F0080";  // battery-70')
        content.append(f'{indent}  else if (level <= 80) icon = "\\U000F0081";  // battery-80')
        content.append(f'{indent}  else if (level <= 90) icon = "\\U000F0082";  // battery-90')
        content.append(f'{indent}  else                  icon = "\\U000F0079";  // battery (full)')
        content.append(f'{indent}  it.printf({x}, {y}, id({font_id}), {fg}, "%s", icon);')
        content.append(f'{indent}  // Show percentage below icon, centered')
        # Calculate center X relative to the ICON size, not the widget width
        # The icon is drawn at (x,y) with width 'size'
        cx = x + size // 2
        content.append(f'{indent}  it.printf({cx}, {y}+{size}+2, id(font_small), {fg}, TextAlign::TOP_CENTER, "%.0f%%", level);')
        content.append(f'{indent}}}')
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Weather icon widget - dynamic icon based on weather state
    if wtype == "weather_icon":
        entity_id = (widget.entity_id or "").strip()
        size = int(props.get("size", 48) or 48)
        font_id = f"font_mdi_{size}"
        
        if not entity_id:
            content.append(f'{indent}// widget:weather_icon id:{widget.id} type:weather_icon x:{x} y:{y} w:{w} h:{h} size:{size} color:{base_color} (no entity)')
            content.append(f'{indent}it.printf({x}, {y}, id({font_id}), {fg}, "\\U000F0591"); // sunny placeholder')
            _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
            return

        if "." in entity_id:
            safe_id = entity_id.replace(".", "_").replace("-", "_")
        else:
            safe_id = entity_id
            
        content.append(f'{indent}// widget:weather_icon id:{widget.id} type:weather_icon x:{x} y:{y} w:{w} h:{h} ent:{entity_id} size:{size} color:{base_color}')
        
        # Generate C++ lambda to map weather state to icon
        content.append(f'{indent}{{')
        content.append(f'{indent}  std::string state = id({safe_id}).state;')
        content.append(f'{indent}  const char* icon = "\\U000F0591"; // default sunny')
        content.append(f'{indent}  if (state == "clear-night") icon = "\\U000F0594";')
        content.append(f'{indent}  else if (state == "cloudy") icon = "\\U000F0595";')
        content.append(f'{indent}  else if (state == "fog") icon = "\\U000F192C";')
        content.append(f'{indent}  else if (state == "hail") icon = "\\U000F0E6E";')
        content.append(f'{indent}  else if (state == "lightning") icon = "\\U000F0598";')
        content.append(f'{indent}  else if (state == "lightning-rainy") icon = "\\U000F067F";')
        content.append(f'{indent}  else if (state == "partlycloudy") icon = "\\U000F0599";')
        content.append(f'{indent}  else if (state == "pouring") icon = "\\U000F06A1";')
        content.append(f'{indent}  else if (state == "rainy") icon = "\\U000F0596";')
        content.append(f'{indent}  else if (state == "snowy") icon = "\\U000F0590";')
        content.append(f'{indent}  else if (state == "snowy-rainy") icon = "\\U000F0F32";')
        content.append(f'{indent}  else if (state == "sunny") icon = "\\U000F0591";')
        content.append(f'{indent}  else if (state == "windy") icon = "\\U000F0597";')
        content.append(f'{indent}  else if (state == "windy-variant") icon = "\\U000F0F2F";')
        content.append(f'{indent}  else if (state == "exceptional") icon = "\\U000F0024";')
        content.append(f'{indent}  it.printf({x}, {y}, id({font_id}), {fg}, "%s", icon);')
        content.append(f'{indent}}}')
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Graph widget
    if wtype == "graph":
        entity_id = (widget.entity_id or "").strip()
        title = (widget.title or "").replace('"', '\\"')
        duration = props.get("duration", "1h")
        border = str(props.get("border", True)).lower()
        x_grid = props.get("x_grid", "")
        y_grid = props.get("y_grid", "")
        line_type = props.get("line_type", "SOLID")
        line_thickness = int(props.get("line_thickness", 3))
        continuous = str(props.get("continuous", True)).lower()
        min_value = props.get("min_value", "")
        max_value = props.get("max_value", "")
        min_range = props.get("min_range", "")
        max_range = props.get("max_range", "")
        is_local = "true" if props.get("is_local_sensor") else "false"
        
        # Generate safe ID
        safe_id = f"graph_{widget.id}".replace("-", "_")
        
        # Marker comment
        content.append(f'{indent}// widget:graph id:{widget.id} type:graph x:{x} y:{y} w:{w} h:{h} title:"{title}" entity:{entity_id} local:{is_local} duration:{duration} border:{border} color:{base_color} x_grid:{x_grid} y_grid:{y_grid} line_type:{line_type} line_thickness:{line_thickness} continuous:{continuous} min_value:{min_value} max_value:{max_value} min_range:{min_range} max_range:{max_range}')
        
        if entity_id:
            # Draw graph
            content.append(f'{indent}it.graph({x}, {y}, id({safe_id}));')
            
            if title:
                content.append(f'{indent}it.printf({x}+4, {y}+2, id(font_small), {fg}, TextAlign::TOP_LEFT, "{title}");')
            
            # --- Generate Axis Labels ---
            try:
                min_val = float(min_value) if min_value else 0.0
                max_val = float(max_value) if max_value else 100.0
                
                # Y-Axis Labels
                y_range = max_val - min_val
                y_steps = 4
                for i in range(y_steps + 1):
                    val = min_val + (y_range * (i / y_steps))
                    y_offset = int(h * (1 - (i / y_steps)))
                    # Adjust Y slightly to center text vertically (approx -6px for small font)
                    # Smart formatting: use %.0f if range >= 10, else %.1f
                    fmt = "%.0f" if y_range >= 10 else "%.1f"
                    content.append(f'{indent}it.printf({x} - 4, {y} + {y_offset} - 6, id(font_small), {fg}, TextAlign::TOP_RIGHT, "{fmt}", (float){val});')
                
                # X-Axis Labels
                duration_sec = 3600
                import re
                match = re.match(r'^(\d+)([a-z]+)$', duration, re.IGNORECASE)
                if match:
                    v = int(match.group(1))
                    u = match.group(2).lower()
                    if u.startswith("s"): duration_sec = v
                    elif u.startswith("m"): duration_sec = v * 60
                    elif u.startswith("h"): duration_sec = v * 3600
                    elif u.startswith("d"): duration_sec = v * 86400

                x_steps = 2
                for i in range(x_steps + 1):
                    ratio = i / x_steps
                    x_offset = int(w * ratio)
                    align = "TextAlign::TOP_CENTER"
                    if i == 0: align = "TextAlign::TOP_LEFT"
                    if i == x_steps: align = "TextAlign::TOP_RIGHT"
                    
                    label_text = ""
                    if i == x_steps:
                        label_text = "Now"
                    else:
                        time_ago = duration_sec * (1 - ratio)
                        if time_ago >= 3600: label_text = f"-{time_ago/3600:.1f}h"
                        elif time_ago >= 60: label_text = f"-{time_ago/60:.0f}m"
                        else: label_text = f"-{time_ago:.0f}s"
                    
                    content.append(f'{indent}it.printf({x} + {x_offset}, {y} + {h} + 2, id(font_small), {fg}, {align}, "{label_text}");')

            except ValueError:
                pass # Skip labels if min/max are not valid numbers

        else:
            # Placeholder for no entity
            content.append(f'{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});')
            content.append(f'{indent}it.printf({x}+5, {y}+5, id(font_small), {fg}, TextAlign::TOP_LEFT, "Graph (no entity)");')

        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Rectangle / filled rectangle
    if wtype == "shape_rect":
        fill = bool(props.get("fill"))
        border_width = int(props.get("border_width", 1) or 1)
        opacity = int(props.get("opacity", 100) or 100)
        
        # Add marker comment for parser
        fill_str = "true" if fill else "false"
        content.append(f'{indent}// widget:shape_rect id:{widget.id} type:shape_rect x:{x} y:{y} w:{w} h:{h} fill:{fill_str} border:{border_width} opacity:{opacity} color:{base_color}')
        
        # Check if we should use grey dithering pattern (50% checkerboard)
        use_grey_pattern = (base_color == "gray" and fill)
        
        if fill:
            if use_grey_pattern:
                # Grey: create 50% checkerboard pattern for visual distinction from solid black
                content.append(f"{indent}// Opaque Grey fill using 50% checkerboard dithering pattern")
                content.append(f"{indent}for (int dy = 0; dy < {h}; dy++) {{")
                content.append(f"{indent}  for (int dx = 0; dx < {w}; dx++) {{")
                content.append(f"{indent}    if ((dx + dy) % 2 == 0) {{")
                content.append(f"{indent}      it.draw_pixel_at({x}+dx, {y}+dy, COLOR_ON);")
                content.append(f"{indent}    }} else {{")
                content.append(f"{indent}      it.draw_pixel_at({x}+dx, {y}+dy, COLOR_OFF);")
                content.append(f"{indent}    }}")
                content.append(f"{indent}  }}")
                content.append(f"{indent}}}")
            elif opacity < 100:
                # Opacity simulation using dithering
                # Simple dithering: skip pixels based on opacity
                # 75% opacity = draw 3/4 pixels
                # 50% opacity = draw 1/2 pixels (checkerboard)
                # 25% opacity = draw 1/4 pixels
                content.append(f"{indent}// Opacity {opacity}% simulation")
                content.append(f"{indent}for (int dy = 0; dy < {h}; dy++) {{")
                content.append(f"{indent}  for (int dx = 0; dx < {w}; dx++) {{")
                threshold = int(opacity * 2.55) # Map 0-100 to 0-255
                # Use a simple pseudo-random or pattern based check
                # (dx*3 + dy*7) % 100 < opacity
                content.append(f"{indent}    if (((dx*3 + dy*7) % 100) < {opacity}) {{")
                content.append(f"{indent}      it.draw_pixel_at({x}+dx, {y}+dy, {fg});")
                content.append(f"{indent}    }}")
                content.append(f"{indent}  }}")
                content.append(f"{indent}}}")
            else:
                # Solid fill (black or white)
                content.append(f"{indent}it.filled_rectangle({x}, {y}, {w}, {h}, {fg});")
            if border_width > 1:
                content.append(f"{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});")
        else:
            if border_width <= 1:
                content.append(f"{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});")
            else:
                # Approximate thicker border using multiple rectangles.
                content.append(f"{indent}// rectangle with border_width={border_width}")
                content.append(f"{indent}for (int i = 0; i < {border_width}; i++) {{")
                content.append(
                    f"{indent}  it.rectangle({x}+i, {y}+i, {w}-2*i, {h}-2*i, {fg});"
                )
                content.append(f"{indent}}}")
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return



    # Circle / filled circle (use width/height box)
    if wtype == "shape_circle":
        # Revert to simple circle logic (no ellipse support in ESPHome display)
        # Use the smaller dimension to ensure it fits
        r = min(w, h) // 2
        cx = x + (w // 2)
        cy = y + (h // 2)
        fill = bool(props.get("fill"))
        border_width = int(props.get("border_width", 1) or 1)
        opacity = int(props.get("opacity", 100) or 100)
        
        # Add marker comment for parser
        fill_str = "true" if fill else "false"
        content.append(f'{indent}// widget:shape_circle id:{widget.id} type:shape_circle x:{x} y:{y} w:{w} h:{h} fill:{fill_str} border:{border_width} opacity:{opacity} color:{base_color}')
        
        # Check if we should use grey dithering pattern
        use_grey_pattern = (base_color == "gray" and fill)
        
        if fill:
            if use_grey_pattern:
                # Grey: create 50% checkerboard pattern within circle
                content.append(f"{indent}// Opaque Grey fill using 50% checkerboard dithering pattern")
                content.append(f"{indent}for (int dy = -{r}; dy <= {r}; dy++) {{")
                content.append(f"{indent}  for (int dx = -{r}; dx <= {r}; dx++) {{")
                content.append(f"{indent}    if (dx*dx + dy*dy <= {r}*{r}) {{")
                content.append(f"{indent}      if ((dx + dy) % 2 == 0) {{")
                content.append(f"{indent}        it.draw_pixel_at({cx}+dx, {cy}+dy, COLOR_ON);")
                content.append(f"{indent}      }} else {{")
                content.append(f"{indent}        it.draw_pixel_at({cx}+dx, {cy}+dy, COLOR_OFF);")
                content.append(f"{indent}      }}")
                content.append(f"{indent}    }}")
                content.append(f"{indent}  }}")
                content.append(f"{indent}}}")
            elif opacity < 100:
                # Opacity simulation
                content.append(f"{indent}// Opacity {opacity}% simulation")
                content.append(f"{indent}for (int dy = -{r}; dy <= {r}; dy++) {{")
                content.append(f"{indent}  for (int dx = -{r}; dx <= {r}; dx++) {{")
                content.append(f"{indent}    if (dx*dx + dy*dy <= {r}*{r}) {{")
                content.append(f"{indent}      if (((dx*3 + dy*7) % 100) < {opacity}) {{")
                content.append(f"{indent}        it.draw_pixel_at({cx}+dx, {cy}+dy, {fg});")
                content.append(f"{indent}      }}")
                content.append(f"{indent}    }}")
                content.append(f"{indent}  }}")
                content.append(f"{indent}}}")
            else:
                # Solid fill
                content.append(f"{indent}it.filled_circle({cx}, {cy}, {r}, {fg});")
            
            if border_width > 1:
                content.append(f"{indent}it.circle({cx}, {cy}, {r}, {fg});")
        else:
            if border_width <= 1:
                content.append(f"{indent}it.circle({cx}, {cy}, {r}, {fg});")
            else:
                content.append(f"{indent}// border_width={border_width}")
                content.append(f"{indent}for (int i = 0; i < {border_width}; i++) {{")
                content.append(f"{indent}  it.circle({cx}, {cy}, {r}-i, {fg});")
                content.append(f"{indent}}}")
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Line: from (x,y) to (x+width,y+height) using width/height as dx/dy
    if wtype == "line":
        dx = w
        dy = h
        stroke_width = int(props.get("stroke_width", 1) or 1)
        # Add marker comment for parser
        content.append(f'{indent}// widget:line id:{widget.id} type:line x:{x} y:{y} w:{w} h:{h} stroke:{stroke_width} color:{base_color}')
        
        # For straight lines: use only the dominant direction
        # If mostly horizontal (|dx| > |dy|), make it perfectly horizontal (dy=0)
        # If mostly vertical (|dy| > |dx|), make it perfectly vertical (dx=0)
        # This prevents "crooked" lines where users expect horizontal but set height>0
        if abs(dx) > abs(dy):
            # Horizontal line - force y2 = y1
            end_y = y  # NOT y+dy
        else:
            # Vertical line - keep dy, but could force x2 = x1 if desired
            end_y = y + dy
            
        if abs(dy) > abs(dx):
            # Vertical line - force x2 = x1  
            end_x = x  # NOT x+dx
        else:
            # Horizontal line - keep dx
            end_x = x + dx
        
        # Draw line from (x,y) to (end_x, end_y)
        # For thick lines (stroke_width > 1), draw parallel lines
        if stroke_width <= 1:
            content.append(f"{indent}it.line({x}, {y}, {end_x}, {end_y}, {fg});")
        else:
            # Draw multiple parallel lines for thickness
            content.append(f"{indent}// Line with stroke_width={stroke_width}")
            content.append(f"{indent}for (int i = 0; i < {stroke_width}; i++) {{")
            # Offset perpendicular to line direction
            if abs(dx) > abs(dy):  # Horizontal line - offset vertically
                content.append(f"{indent}  it.line({x}, {y}+i, {end_x}, {end_y}+i, {fg});")
            else:  # Vertical line - offset horizontally
                content.append(f"{indent}  it.line({x}+i, {y}, {end_x}+i, {end_y}, {fg});")
            content.append(f"{indent}}}")
        
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Graph widget
    if wtype == "graph":
        entity_id = (widget.entity_id or "").strip()
        duration = props.get("duration", "1h")
        border = bool(props.get("border", True))
        color_prop = (props.get("color") or "black").lower()
        title = (widget.title or "").replace('"', '\\"')
        
        # Additional graph props for persistence
        x_grid = props.get("x_grid", "")
        y_grid = props.get("y_grid", "")
        line_type = props.get("line_type", "")
        line_thickness = props.get("line_thickness", "")
        min_value = props.get("min_value", "")
        max_value = props.get("max_value", "")
        min_range = props.get("min_range", "")
        max_range = props.get("max_range", "")
        continuous = "true" if props.get("continuous") else "false"
        is_local = "true" if props.get("is_local_sensor") else "false"
        
        safe_id = f"graph_{widget.id}".replace("-", "_")

        if not entity_id:
            content.append(f'{indent}// widget:graph id:{widget.id} type:graph x:{x} y:{y} w:{w} h:{h} duration:"{duration}" border:{border} color:{color_prop} title:"{title}" (no entity)')
            content.append(f'{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});')
            content.append(f'{indent}it.line({x}, {y}+{h}, {x}+{w}, {y}, {fg});')
            content.append(f'{indent}it.printf({x}+5, {y}+5, id(font_small), {fg}, "Graph (no entity)");')
        else:
            show_axis_labels = "true" if props.get("show_axis_labels") else "false"
            content.append(f'{indent}// widget:graph id:{widget.id} type:graph x:{x} y:{y} w:{w} h:{h} entity:"{entity_id}" duration:"{duration}" border:"{border}" color:"{color_prop}" x_grid:"{x_grid}" y_grid:"{y_grid}" line_type:"{line_type}" line_thickness:"{line_thickness}" min_value:"{min_value}" max_value:"{max_value}" min_range:"{min_range}" max_range:"{max_range}" continuous:"{continuous}" local:"{is_local}" title:"{title}" show_axis_labels:"{show_axis_labels}"')
            content.append(f'{indent}it.graph({x}, {y}, id({safe_id}));')
            
            # Render title if present
            if title:
                # Draw title in top-left corner with small font
                content.append(f'{indent}it.printf({x}+4, {y}+2, id(font_small), {fg}, "{title}");')

            # Render Axis Labels if enabled and min/max are set
            if props.get("show_axis_labels") and min_value and max_value:
                # Smart Positioning: Flip Y-axis labels if too close to left edge
                flip_y = x < 30
                
                # Y-Axis Labels
                if flip_y:
                    # Right side
                    content.append(f'{indent}it.printf({x}+{w}+2, {y}-6, id(font_axis), {fg}, TextAlign::TOP_LEFT, "{max_value}");')
                    content.append(f'{indent}it.printf({x}+{w}+2, {y}+{h}-6, id(font_axis), {fg}, TextAlign::BOTTOM_LEFT, "{min_value}");')
                else:
                    # Left side
                    content.append(f'{indent}it.printf({x}-2, {y}-6, id(font_axis), {fg}, TextAlign::TOP_RIGHT, "{max_value}");')
                    content.append(f'{indent}it.printf({x}-2, {y}+{h}-6, id(font_axis), {fg}, TextAlign::BOTTOM_RIGHT, "{min_value}");')
                
                # X-Axis Labels
                # Start (Duration)
                content.append(f'{indent}it.printf({x}, {y}+{h}+2, id(font_axis), {fg}, TextAlign::TOP_LEFT, "-{duration}");')
                # End (Now)
                content.append(f'{indent}it.printf({x}+{w}, {y}+{h}+2, id(font_axis), {fg}, TextAlign::TOP_RIGHT, "Now");')

        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Image widget
    if wtype == "image":
        path = (props.get("path") or "").strip()
        invert = bool(props.get("invert"))
        
        if path:
            # Generate safe ID from path (same logic as in _generate_fonts)
            safe_path = path.replace("/", "_").replace(".", "_").replace("-", "_").replace(" ", "_")
            # IMPORTANT: Include dimensions in ID to match the definition in _generate_fonts
            safe_id = f"img_{safe_path}_{w}x{h}"
            
            # Add marker comment for parser
            content.append(f'{indent}// widget:image id:{widget.id} type:image x:{x} y:{y} w:{w} h:{h} path:"{path}" invert:{invert}')
            
            if invert:
                content.append(f"{indent}it.image({x}, {y}, id({safe_id}), COLOR_OFF, COLOR_ON);")
            else:
                content.append(f"{indent}it.image({x}, {y}, id({safe_id}));")
        else:
            content.append(f'{indent}// widget:image id:{widget.id} type:image x:{x} y:{y} w:{w} h:{h} (no path)')
            content.append(f'{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});')
            
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # History widget: placeholder visualization; requires precomputed entity
    if wtype == "history":
        entity_id = (props.get("entity_id") or widget.entity_id or "").replace('"', '\\"')
        style = (props.get("style") or "bars").lower()
        label = entity_id or "history"
        font = _resolve_font(props)
        content.append(f"{indent}// history widget for {entity_id}; expects external aggregation")
        content.append(f'{indent}it.print({x}, {y}, {font}, {fg}, "{label}");')
        # Simple placeholder box/lines
        hx = x
        hy = y + 14
        hw = max(10, w)
        hh = max(6, h - 16)
        content.append(f"{indent}it.rectangle({hx}, {hy}, {hw}, {hh}, {fg});")
        if style == "line":
            content.append(f"{indent}it.line({hx+2}, {hy+hh-3}, {hx+hw-2}, {hy+3}, {fg});")
        else:
            content.append(f"{indent}// draw simple bar-style segments as placeholder")
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Online Image widget
    if wtype == "online_image":
        url = (props.get("url") or "").strip()
        invert = bool(props.get("invert"))
        # IMPORTANT: Must match ID from _generate_online_images
        safe_id = f"online_image_{widget.id}".replace("-", "_")
        
        # Add invert property to marker comment
        content.append(f'{indent}// widget:online_image id:{widget.id} type:online_image x:{x} y:{y} w:{w} h:{h} url:"{url}" invert:{str(invert).lower()}')
        
        # Render with color inversion if enabled
        if invert:
            content.append(f"{indent}it.image({x}, {y}, id({safe_id}), COLOR_OFF, COLOR_ON);")
        else:
            content.append(f"{indent}it.image({x}, {y}, id({safe_id}));")
        
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Puppet widget (online image wrapper)
    if wtype == "puppet":
        url = (props.get("image_url") or "").strip()
        invert = bool(props.get("invert"))
        # IMPORTANT: Must match ID from _generate_online_images
        safe_id = f"puppet_{widget.id}".replace("-", "_")
        
        # Add invert property to marker comment
        content.append(f'{indent}// widget:puppet id:{widget.id} type:puppet x:{x} y:{y} w:{w} h:{h} url:"{url}" invert:{str(invert).lower()}')
        
        # Render with color inversion if enabled
        if invert:
            content.append(f"{indent}it.image({x}, {y}, id({safe_id}), COLOR_OFF, COLOR_ON);")
        else:
            content.append(f"{indent}it.image({x}, {y}, id({safe_id}));")
        
        _wrap_with_condition(dst, indent, widget, content, numeric_entity_ids)
        return

    # Unknown type: emit comment for safety
    dst.append(f'{indent}// TODO: unsupported widget type "{widget.type}" at ({x},{y})')
