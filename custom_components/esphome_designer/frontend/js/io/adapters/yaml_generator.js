/**
 * Modular YAML generator for ESPHome.
 * Handles the structural components of the generated configuration.
 */
export class YamlGenerator {
    /**
     * Generates the instruction header with setup guidance.
     * @param {Object} profile 
     * @param {Object} layout 
     * @returns {string[]}
     */
    generateInstructionHeader(profile, layout) {
        const lines = [];
        lines.push("# ============================================================================");
        lines.push("# ESPHome YAML - Generated by ESPHome Designer");
        lines.push("# ============================================================================");
        lines.push(`# TARGET DEVICE: ${profile.name || "Unknown"}`);

        // Add brief device specs comment based on profile features
        const feats = profile.features || {};
        const platform = profile.displayPlatform || (feats.lcd ? (profile.id === 'reterminal_e1001' ? 'reterminal_e1001' : 'LCD') : (feats.epaper ? "waveshare_epaper" : "Unknown"));

        lines.push(`#         - Display Platform: ${platform}`);
        lines.push(`#         - PSRAM: ${feats.psram ? 'Yes' : 'No'}`);
        lines.push(`#         - Touchscreen: ${feats.touch ? (profile.touch?.platform || 'Yes') : 'No'}`);

        let frameworkHint = "esp-idf (Recommended)";
        if (feats.psram && (profile.chip?.includes("s3") || profile.id?.includes("s3"))) {
            frameworkHint = "ESP-IDF (Required for stable PSRAM/LVGL)";
        }
        lines.push(`#         - Framework: ${frameworkHint}`);

        lines.push("# ============================================================================");
        lines.push("#");
        lines.push("# SETUP INSTRUCTIONS:");
        lines.push("#");
        lines.push("# STEP 1: Copy the Material Design Icons font file");
        lines.push("#         - From this repo: resources/fonts/materialdesignicons-webfont.ttf");
        lines.push("#         - To ESPHome: /config/esphome/fonts/materialdesignicons-webfont.ttf");
        lines.push("#");
        lines.push("# STEP 2: Create a new device in ESPHome");
        lines.push("#         - Click \"New Device\"");
        lines.push("#         - Select: ESP32-S3 (or appropriate for your board)");
        lines.push("#         - Framework: ESP-IDF (Essential for S3 stability)");
        lines.push("#");
        lines.push("# STEP 3: PASTE this snippet into your device YAML");
        lines.push("#         - Paste this snippet at the end of your configuration.");
        lines.push("#         - System sections (esphome, esp32, psram) are auto-commented");
        lines.push("#           to avoid conflicts with your existing base setup.");
        lines.push("#");
        lines.push("# CAPTIVE PORTAL:");
        lines.push("#         - If WiFi connection fails, the device will create a hotspot.");
        lines.push("#         - Search for its name in your WiFi settings.");
        lines.push("#         - Connect and go to http://192.168.4.1 to configure WiFi.");
        lines.push("#");
        lines.push("# TIP: For reTerminal / S3 devices, if you cannot see logs via USB,");
        lines.push("#      add this to your base 'logger:' section:");
        lines.push("#      hardware_uart: USB_CDC");
        lines.push("#");
        lines.push("# ============================================================================");
        lines.push("");
        lines.push("# ====================================");
        lines.push("# Device Settings");
        lines.push("# ====================================");
        lines.push(`# Orientation: ${layout.orientation || "landscape"}`);
        lines.push(`# Dark Mode: ${layout.darkMode ? "enabled" : "disabled"}`);
        lines.push(`# Refresh Interval: ${layout.refreshInterval || 600}`);
        const isLcd = !!(profile.features && (profile.features.lcd || profile.features.oled));
        let strategy;
        if (layout.manualRefreshOnly) {
            strategy = "Manual Refresh Only";
        } else if (isLcd) {
            const lcdStrategy = layout.lcdEcoStrategy || 'backlight_off';
            const map = {
                always_on: 'Always On',
                backlight_off: 'Backlight Off Schedule',
                halt_updates: 'Halt Updates',
                deep_sleep: 'Deep Sleep',
                dim_after_timeout: 'Dim after timeout'
            };
            strategy = map[lcdStrategy] || lcdStrategy;
        } else {
            strategy = layout.deepSleepEnabled ? "Ultra Eco (Deep Sleep)" : (layout.sleepEnabled ? "Eco (Light Sleep)" : "Always On");
        }
        lines.push(`# Power Strategy: ${strategy}`);
        lines.push(`# Deep Sleep Interval: ${layout.deepSleepInterval || 600}`);
        lines.push("# ====================================");
        lines.push("");
        return lines;
    }

    /**
     * Generates a template of system sections, commented out.
     * @param {Object} profile 
     * @returns {string[]}
     */
    generateSystemSections(profile, layout) {
        const lines = [];
        const chip = profile.chip || "esp32-s3";
        const board = profile.board || "esp32-s3-devkitc-1";

        const isEpaper = !!(profile.features && (profile.features.epaper || profile.features.epd));
        // Check for CoreInk specifically (by board or name)
        const isCoreInk = (profile.board === "m5stack-coreink") || (profile.name && profile.name.toLowerCase().includes("coreink"));

        lines.push("# esphome:");
        lines.push("#   name: your-device-name");
        lines.push("#   comment: 'Snippet generated by ESPHome Designer'");
        if (layout.plugin_includes && layout.plugin_includes.length > 0) {
            lines.push("#   includes:");
            layout.plugin_includes.forEach(inc => {
                lines.push(`#     - ${inc}`);
            });
        }
        lines.push("#   on_boot:");
        lines.push("#     priority: 300");
        lines.push("#     then:");

        // Generic output logic (commented out by default)
        if (!isCoreInk) {
            // Special handling for Waveshare PhotoPainter (AXP2101 Manual Config)
            if (profile.id === 'esp32_s3_photopainter') {
                lines.push("#       - lambda: |-");
                lines.push("#           auto write_reg = [](uint8_t reg, uint8_t val) {");
                lines.push("#             uint8_t data[2] = {reg, val};");
                lines.push("#             id(bus_a)->write(0x34, data, 2);");
                lines.push("#           };");
                lines.push("#           write_reg(0x94, 0x1C); // ALDO3 3.3V");
                lines.push("#           write_reg(0x95, 0x1C); // ALDO4 3.3V");
                lines.push("#           write_reg(0x90, 0x1F); // Enable rails");
                lines.push("#           ESP_LOGI(\"power\", \"AXP2101 Configured\");");
                lines.push("#       - delay: 200ms");
                lines.push("#       - component.update: epaper_display");
            }

            if (profile.battery && profile.pins && profile.pins.batteryEnable) {
                lines.push("#       - output.turn_on: bsp_battery_enable");
            }
            if (profile.m5paper?.main_power_pin || profile.pins?.main_power_pin) {
                lines.push("#       - output.turn_on: main_power");
            }
            if (profile.m5paper?.battery_power_pin || profile.pins?.battery_power_pin) {
                lines.push("#       - output.turn_on: battery_power");
            }
            lines.push("#       - delay: 2s");
        }
        // For CoreInk, skip the generic outputs as they are handled by the lambda below

        if (isCoreInk) {
            lines.push("#       # 1. HARDWARE POWER LOCK (ESP-IDF Version)");
            lines.push("#       - lambda: |-");
            lines.push("#           gpio_set_direction(GPIO_NUM_12, GPIO_MODE_OUTPUT);");
            lines.push("#           gpio_set_level(GPIO_NUM_12, 1);");
            lines.push("#           gpio_hold_en(GPIO_NUM_12);");
            lines.push("#           gpio_deep_sleep_hold_en();");
            lines.push("#");
            lines.push("#       # 2. Start the Main Logic Loop");
            lines.push("#       - script.execute: manage_run_and_sleep");
            lines.push("#");
            lines.push("#       # 3. Initial Screen Update");
            lines.push("#       - component.update: epaper_display");
        } else if (isEpaper && layout.deepSleepEnabled) {
            lines.push("#       - script.execute: deep_sleep_cycle");
        } else {
            lines.push("#       - script.execute: manage_run_and_sleep");
        }

        if (layout.autoCycleEnabled) {
            // Keep this commented for now as it's optional
            lines.push("#       - script.execute: auto_cycle_timer");
        }
        if (chip === 'esp8266') {
            lines.push("#");
            lines.push("# esp8266:");
            lines.push(`#   board: ${board || 'nodemcuv2'}`);
        } else {
            lines.push("#");
            lines.push("# esp32:");
            lines.push(`#   board: ${board}`);
            lines.push("#   framework:");
            lines.push("#     type: esp-idf");
            if (chip.includes("s3")) {
                lines.push("#     sdkconfig_options:");
                lines.push("#       CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: y");
                lines.push("#       CONFIG_ESP32S3_DATA_CACHE_64KB: y");
            }
        }
        lines.push("#");
        lines.push("# logger:");
        if (chip.includes("s3")) {
            lines.push("#   hardware_uart: USB_CDC # Enable for USB debugging on S3");
        }
        lines.push("#   level: DEBUG");
        lines.push("#");
        lines.push("# api:");
        lines.push("# ota:");
        lines.push("# wifi:");
        lines.push("#   # ... your wifi config here");

        // Add Deep Sleep component if enabled (E-Ink Only)
        if (isEpaper && layout.deepSleepEnabled) {
            lines.push("");
            lines.push("deep_sleep:");
            lines.push("  id: deep_sleep_control");
            lines.push("  run_duration: 30s # Stay awake 30s on boot for OTA");
            lines.push(`  sleep_duration: ${layout.deepSleepInterval || 600}s`);
        }

        lines.push("");
        return lines;
    }

    /**
     * Generates the script section for page switching and sleep management.
     * @param {Object} payload 
     * @param {Object[]} pages 
     * @param {Object} profile 
     * @returns {string[]}
     */
    generateScriptSection(payload, pages, profile) {
        const lines = [];
        const displayId = profile.features?.lcd ? "my_display" : "epaper_display";
        const autoCycleEnabled = payload.autoCycleEnabled && pages.length > 1;

        const isLcd = !!(profile.features && (profile.features.lcd || profile.features.oled));
        const isEpaper = !!(profile.features && (profile.features.epaper || profile.features.epd));
        const isOled = !!(profile.features && profile.features.oled);
        const debounceMs = isLcd ? 500 : 3000;
        const backlightPin = (profile.backlight && profile.backlight.pin) ? profile.backlight.pin : (profile.pins?.backlight || null);

        // Determine LCD Power Strategy
        const lcdStrategy = payload.lcdEcoStrategy || 'backlight_off';
        const isBacklightStrategy = isLcd && lcdStrategy === 'backlight_off' && backlightPin;
        const isDeepSleep = isEpaper && payload.deepSleepEnabled;

        lines.push("script:");

        // Change Page Script
        lines.push("  - id: change_page_to");
        lines.push("    parameters:");
        lines.push("      target_page: int");
        lines.push("    then:");
        lines.push("      - lambda: |-");
        lines.push(`          int pages_count = ${pages.length};`);
        lines.push("          int target = target_page;");
        lines.push("          while (target < 0) target += pages_count;");
        lines.push("          target %= pages_count;");
        lines.push("");
        lines.push(`          // Debounce: Ignore page changes within ${debounceMs}ms of last change`);
        lines.push(`          // (adjusted for ${isLcd ? 'LCD' : 'e-paper'} display update time)`);
        lines.push("          uint32_t now = millis();");
        lines.push(`          if (now - id(last_page_switch_time) < ${debounceMs}) {`);
        lines.push(`            ESP_LOGD("display", "Page change ignored (debounce), last switch was %d ms ago", now - id(last_page_switch_time));`);
        lines.push("            return;");
        lines.push("          }");
        lines.push("");
        lines.push("          if (id(display_page) != target) {");
        lines.push("            // Set debounce time BEFORE display update (update takes ~1.6s)");
        lines.push("            id(last_page_switch_time) = now;");
        lines.push("            id(display_page) = target;");
        lines.push(`            id(${displayId}).update();`);
        lines.push(`            ESP_LOGI("display", "Switched to page %d", target);`);
        lines.push("            // Restart refresh logic");
        lines.push("            if (id(manage_run_and_sleep).is_running()) id(manage_run_and_sleep).stop();");
        lines.push("            id(manage_run_and_sleep).execute();");
        if (isBacklightStrategy) {
            lines.push(`            // LCD Strategy: Wake up backlight on interaction/page change`);
            lines.push(`            id(backlight_pwm).set_level(0.8); // Restore brightness`);
        }
        lines.push("          }");

        // Deep Sleep Cycle Script (E-Ink Only)
        if (isDeepSleep) {
            lines.push("");
            lines.push("  - id: deep_sleep_cycle");
            lines.push("    then:");
            lines.push("      - logger.log: \"Waiting for sync before Deep Sleep...\"");
            lines.push("      - wait_until:");
            lines.push("          condition:");
            lines.push("            lambda: 'return id(ha_time).now().is_valid() && api_is_connected();'");
            lines.push("          timeout: 60s");
            lines.push("      - delay: 5s");
            lines.push(`      - component.update: ${displayId}`);
            lines.push("      - delay: 5s # Ensure refresh starts before sleep");
            lines.push("      - logger.log: \"Entering Deep Sleep now...\"");
            lines.push("      - deep_sleep.enter: deep_sleep_control");
        }

        // Manage Run and Sleep (Looping version)
        lines.push("");
        lines.push("  - id: manage_run_and_sleep", "    mode: restart", "    then:");

        // Ensure Main Power is on (critical for M5Paper)
        if (profile.m5paper?.main_power_pin || profile.pins?.main_power_pin) {
            lines.push("      - output.turn_on: main_power");
        }
        if (profile.m5paper?.battery_power_pin || profile.pins?.battery_power_pin) {
            lines.push("      - output.turn_on: battery_power");
        }

        lines.push("      - logger.log: \"Waiting for sync...\"");
        lines.push("      - wait_until:");
        lines.push("          condition:");
        lines.push("            lambda: 'return id(ha_time).now().is_valid() && api_is_connected();'");
        lines.push("          timeout: 60s");
        lines.push("      - delay: 5s");

        // Logic for Sleep & Refresh
        lines.push("      - lambda: |-");
        lines.push("          int p = id(display_page);");
        lines.push("          int interval = id(page_refresh_default_s);");
        lines.push("          bool is_sleep_time = false;");

        // Date/Time Check
        const sStart = parseInt(payload.sleepStartHour) || 0;
        const sEnd = parseInt(payload.sleepEndHour) || 0;
        const sEnabled = !!payload.sleepEnabled;

        lines.push("          auto time = id(ha_time).now();");
        lines.push("          if (time.is_valid()) {");
        lines.push(`             int hour = time.hour;`);
        lines.push(`             int start = ${sStart};`);
        lines.push(`             int end = ${sEnd};`);
        lines.push("             if (start < end) {");
        lines.push("                 if (hour >= start && hour < end) is_sleep_time = true;");
        lines.push("             } else {");
        lines.push("                 if (hour >= start || hour < end) is_sleep_time = true;");
        lines.push("             } ");
        lines.push("          }");

        // LCD vs E-Paper Strategy in the loop
        if (isLcd) {
            if (isBacklightStrategy) {
                // Backlight Off Strategy
                lines.push("          #ifdef USE_BACKLIGHT");
                lines.push("          if (is_sleep_time) {");
                lines.push("              auto call = id(backlight_pwm).make_call();");
                lines.push("              call.set_brightness(0.0);");
                lines.push("              call.perform();");
                lines.push(`              interval = 3600; // Check back in an hour`);
                lines.push("          } else {");
                lines.push("              auto call = id(backlight_pwm).make_call();");
                lines.push("              call.set_brightness(0.8);");
                lines.push("              call.perform();");
                lines.push("          }");
                lines.push("          #endif");
            } else if (isOled && sEnabled) {
                // OLED OFF Strategy (using component.update suppression or similar?)
                // For now, let's just use the interval skip
                lines.push("          if (is_sleep_time) {");
                lines.push("              // OLED specific: Blank screen or similar would go here");
                lines.push(`              interval = 3600;`);
                lines.push("          }");
            }
        } else {
            // E-Paper Strategy (Sleep Enabled)
            if (sEnabled && !isDeepSleep) {
                lines.push("          if (is_sleep_time) {");
                lines.push(`              interval = 3600; // Sleep for an hour (skip updates)`);
                lines.push("          }");
            }
        }

        // Inject per-page refresh settings (Only if NOT sleeping)
        lines.push(`          if (!is_sleep_time) {`);
        pages.forEach((p, idx) => {
            const refresh = parseInt(p.refresh_s);
            if (!isNaN(refresh) && refresh > 0) {
                lines.push(`            if (p == ${idx}) interval = ${refresh};`);
            }
        });
        lines.push(`          }`);

        lines.push("          id(page_refresh_current_s) = interval;");

        lines.push(`      - component.update: ${displayId}`);

        // Manual Refresh Only: Do NOT loop. Stop after initial update.
        const isManualRefresh = !!payload.manualRefreshOnly;
        if (!isManualRefresh) {
            lines.push("      - delay: !lambda 'return id(page_refresh_current_s) * 1000;'");
            lines.push("      - script.execute: manage_run_and_sleep");
        } else {
            lines.push("      - logger.log: \"Manual Refresh Only mode: stopping automatic refresh loop.\"");
        }

        // Auto Cycle Timer
        if (autoCycleEnabled) {
            const globalInterval = payload.autoCycleIntervalS || 30;
            lines.push("  - id: auto_cycle_timer", "    mode: restart", "    then:");

            // Allow per-page cycle time override? 
            // The user complained about page refresh ignoring values.
            // If they want per-page cycle, they might set refresh_s and expect it to apply to cycle.
            // Let's attempt to support dynamic cycle time too using the same variable or a new logic.
            // BUT for safety, let's keep global interval as default, but check if page has refresh_s?
            // No, refresh_s is for Update Interval. cycling is different.
            // I'll stick to global interval for cycling but ensure it works.

            lines.push(`      - delay: ${globalInterval}s`);
            lines.push("      - script.execute:");
            lines.push("          id: change_page_to");
            lines.push("          target_page: !lambda 'return id(display_page) + 1;'");
            lines.push("      - script.execute: auto_cycle_timer");
        }

        return lines;
    }
}
